# 2024 面试准备

# 3、JVM 部分面试题

## JVM

### 具体问题

- JVM了解吗，说说所知道的
  （？？我讲了内存区域、垃圾回收、类加载，然后，面试官说可以了）

- 你平时用的JVM版本是什么？最新版本是什么？

- **为什么要指针压缩，为什么能指针压缩？原理是什么？**

- 能说一下JVM的模型吗？

- 说说jvm？（说了内存区域和垃圾回收）

- 垃圾回收算法，jvm运行时区域等

- **JVM虚拟机启动有哪些线程？**

- **staic 和 final 关键字结合 jvm 来讲**

- GC 底层算法，JVM 内存模型，常见的垃圾回收器，双亲委派的类加载流程；

- 讲下 JVM。这块主要我自己在说，一口气说下来说了有二十多分钟吧，面试官一直没说话，我就一直说，从运行时数据区，讲到一个类具体是如何存储的，再讲到垃圾回收机制和垃圾收集算法，再讲到各个版本的 JDK 的垃圾收集器，再讲到 YoungGC 和 FullGC，再讲 YoungGC 的具体过程，对象是如何分配的，出现 OOM 时如何排查，已经自己在项目的一个 GC 调优做的具体工作  

- 问我a=2,b=1,c=a+b底层具体是一个什么样的过程，答了java内存的分布，具体在哪个位置，比如常量池在方法区，然后栈存对常量的应用之类的。
  问底层呢我答内存拷贝，问有多少次内存拷贝，然后又问在多核cpu和多线程下，然后也是这种情况，cpu和底层又具体是什么样的过程，互相之间怎么影响，怎么不影响。

- 问我对jvm的垃圾回收了解吗，说了从新生代到老年代的整体的过程，用什么垃圾回收算法，举了几个垃圾回收器的例子，说来空间分配担保和可能产生full gc的原因，反正尽可能细的去说自己知道的，越细越好。

- 讲讲 GC，初生代有哪几个块，怎么晋升到老年代，什么时候是 FULL GC，最好再给他讲讲 JVM 调优，我一般都说这是我作为兴趣爱好了解的，了解的不深，不懂的水面试官会觉得你再谦虚，懂得你就说了解的比较少，可能听过-xx 之类的命令把初生代内存设置大一些，少一些 Minor GC 会提升性能之类的。

- JVM 调优的目的？GC 的种类？垃圾回收算法有哪些？好像还问了为什么要分区。(笔试的时候有关于 JVM 参数的一些问题，我没背)

- 这三行代码 jvm 做了什么事情

  - ```java
    String a = "123";
    String b = new("456");
    String c = a + b;
    ```

- jvm 内存结构，垃圾回收策略，垃圾回收算法

### 思考方向

- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》目录
  1. 走近 Java
     - 1.4 Java 虚拟机家族
       - 1.4.1 Sun Classic/Exact VM
         - 虚拟机始祖，JDK 1.4 退出商用虚拟机历史舞台
       - 1.4.2 HostSpot VM
         - Sun/Oracle JDK 和 OpenJDK 的默认虚拟机，也是目前使用最广的 Java 虚拟机
       - 1.4.3 Mobile/Embedded VM
         - 移动和嵌入式
       - 1.4.4 BEA JRockit / IBM J9 VM
         - BEA 已被 Oracle 收购，JDK 6 开始 JRockit 不再发展
         - J9 已完全开源，捐献给 Eclipse 基金会管理
       - 1.4.5 BEA Liquid VM / Azul VM
         - 与特定硬件平台绑定、软硬件配合工作的专有虚拟机
       - 1.4.6 Apache Harmony / Google Android Dalvik VM
         - 挑战者，不算严格的“Java 虚拟机”
       - 1.4.7 Microsoft JVM
         - Windows XP SP3 中 Java 虚拟机被完全抹去
     - 1.5 展望 Java 技术的未来
       - 1.5.1 无语言倾向
         - Graal VM
       - 1.5.2 新一代即时编译器
         - Graal 编译器
       - 1.5.3 向 Native 迈进
         - Substrate VM
       - 1.5.4 灵活的胖子
         - 在 JDK 9 时期，HotSpot 虚拟机开放了 Java 语言级别的编译器接口（Java Virtual Machine Compiler Interface，JVMCI）
         - 到了 JDK 10，HotSpot 又重构了Java虚拟机的垃圾收集器接口（Java Virtual Machine Compiler Interface），统一了其内部各款垃圾收集器的公共行为。
       - 1.5.5 语言语法持续增强
         - Coins 项目（在 JDK 7 已结束，反映 Java 语言中的微小变动）
         - Amber 项目（Coins 后新的语言特性改进项目）
         - Loom 项目（虚拟线程）
         - Valhalla 项目（提供值类型和基本类型的泛型支持，并提供明确的不可变类型和非引用类型的声明）
         - Panama 项目（目的是消弭Java虚拟机与本地代码之间的界线）
  2. Java 内存区域与内存溢出异常
     - 2.2 运行时数据区域
       - 2.2.1 程序计数器
         - 线程隔离
       - 2.2.2 Java 虚拟机栈
         - 线程隔离
       - 2.2.3 本地方法栈
         - 线程隔离
       - 2.2.4 Java 堆
         - 所有线程共享
       - 2.2.5 方法区
         - 所有线程共享
       - 2.2.6 运行时常量池
       - 2.2.7 直接内存
     - 2.3 HotSpot 虚拟机对象探秘
       - 2.3.1 对象的创建
       - 2.3.2 对象的内存布局
         - 对象头
         - 实例数据
         - 对齐填充
       - 2.3.3 对象的访问定位
         - 句柄
         - 直接指针
     - 2.4 实战：OutOfMemoryError 异常
       - 2.4.1 Java 堆溢出
       - 2.4.2 虚拟机栈和本地方法栈溢出
       - 2.4.3 方法区和运行时常量池溢出
       - 2.4.4 本地直接内存溢出
  3. 垃圾收集器与内存分配策略
     - 3.2 对象已死？
       - 3.2.1 引用计数算法
       - 3.2.2 可达性分析算法
       - 3.2.3 再谈引用
         - 强、软、弱、虚
       - 3.2.4 生存还是死亡？
         - finalize()
       - 3.2.5 回收方法区
         - 方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型
     - 3.3 垃圾收集算法
       - 3.3.1 分代收集理论
       - 3.3.2 标记-清除算法
       - 3.3.3 标记-复制算法
       - 3.3.4 标记-整理算法
     - 3.4 HotSpot 的算法细节实现
       - 3.4.1 根节点枚举
       - 3.4.2 安全点
         - 有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。
       - 3.4.3 安全区域
         - 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。
       - 3.4.4 记忆集和卡表
         - 垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots 扫描范围
         - 可以用一种称为“卡表”（Card Table）的方式去实现记忆集
           - 记录精度为“卡精度”：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
       - 3.4.5 写屏障
         - 写前屏障
         - 写后屏障
           - 直至 G1 收集器出现之前，其他收集器都只用到了写后屏障
       - 3.4.6 并发的可达性分析
         - 并发扫描过程：三色标记（Tri-color Marking）
         - 并发扫描时对象消失问题的两种解决方案：
           - 增量更新（Incremental Update）
           - 原始快照（Snapshot At The Beginning，SATB）
     - **3.5 经典垃圾收集器**
       - 3.5.1 Serial 收集器
       - 3.5.2 ParNew 收集器
       - 3.5.3 Parallel Scavenge 收集器
       - 3.5.4 Serial Old 收集器
       - 3.5.5 Parallel Old 收集器
       - **3.5.6 CMS 收集器**
       - **3.5.7 Garbage First 收集器**
     - 3.6 低延迟垃圾收集器
       - **3.6.1 Shenandoah 收集器**
       - **3.6.2 ZGC 收集器**
     - 3.7 选择合适的垃圾收集器
       - 3.7.1 Epsilon 收集器
       - 3.7.2 收集器的权衡
       - 3.7.3 虚拟机及垃圾收集器日志
       - 3.7.4 垃圾收集器参数总结
     - 3.8 实战：内存分配与回收策略
       - 3.8.1 对象优先在 Eden 分配
       - 3.8.2 大对象直接进入老年代
       - 3.8.3 长期存活的对象将进入老年代
       - 3.8.4 动态对象年龄判定
       - 3.8.5 空间分配担保
  4. **虚拟机性能监控、故障处理工具**
     - 4.2 基础故障处理工具
       - 4.2.1 jps：虚拟机进程状况工具
       - 4.2.2 jstat：虚拟机统计信息监视工具
       - 4.2.3 jinfo：Java 配置信息监视工具
       - 4.2.4 jmap：Java 内存映像工具
       - 4.2.5 jhat：虚拟机堆转储快照分析工具
       - 4.2.6 jstack：Java 堆栈跟踪工具
       - 4.2.7 基础工具总结
     - 4.3 可视化故障处理工具
       - 4.3.1 JHSDB：基于服务性代理的调试工具
       - 4.3.2 JConsole：Java 监视和管理控制台
       - 4.3.3 VisualVM：多合一故障处理工具
       - 4.3.4 Java Mission Control：可持续在线的监控工具
     - 4.4 HotSpot 虚拟机插件及工具
  5. **调优案例分析与实战**
     - 5.2 案例分析
       - 5.2.1 大内存硬件上的程序部署策略
       - 5.2.2 集群间同步导致的内存溢出
       - 5.2.3 堆外内存导致的溢出错误
       - 5.2.4 外部命令导致系统缓慢
       - 5.2.5 服务器虚拟机进程崩溃
       - 5.2.6 不恰当数据结构导致内存占用过大
       - 5.2.7 由 Windows 虚拟内存导致的长时间停顿
       - 5.2.8 由安全点导致长时间停顿
     - 5.3 实战：Eclipse 运行速度调优
       - 5.3.1 调优前的程序运行状态
       - 5.3.2 升级 JDK 版本的性能变化及兼容问题
       - 5.3.3 编译时间和类加载时间的优化
       - 5.3.4 调整内存设置控制垃圾收集频率
       - 5.3.5 选择收集器降低延迟
  6. 类文件结构
     - 6.2 无关性的基石
     - 6.3 Class 类文件的结构
       - 6.3.1 魔数与 Class 文件的版本
       - 6.3.2 常量池
       - 6.3.3 访问标志
       - 6.3.4 类索引、父类索引与接口索引集合
       - 6.3.5 字段表集合
       - 6.3.6 方法表集合
       - 6.3.7 属性表集合
     - 6.4 字节码指令简介
       - 6.4.1 字节码与数据类型
       - 6.4.2 加载和存储指令
       - 6.4.3 运算指令
       - 6.4.4 类型转换指令
       - 6.4.5 对象创建与访问指令
       - 6.4.6 操作数栈管理指令
       - 6.4.7 控制转移指令
       - 6.4.8 方法调用和返回指令
       - 6.4.9 异常处理指令
       - 6.4.10 同步指令
     - 6.5 公有设计，私有实现
     - 6.6 Class 文件结构的发展
  7. 虚拟机类加载机制
     - 7.2 类加载的时机
     - **7.3 类加载的过程**
       - 7.3.1 加载
       - 7.3.2 验证
       - 7.3.3 准备
       - 7.3.4 解析
       - 7.3.5 初始化
     - 7.4 类加载器
       - 7.4.1 类与类加载器
       - **7.4.2 双亲委派模型**
       - 7.4.3 破坏双亲委派模型
     - 7.5 Java 模块化系统
       - 7.5.1 模块的兼容性
       - 7.5.2 模块化下的类加载器
  8. 虚拟机字节码执行引擎
     - **8.2 运行时栈帧结构**
       - 8.2.1 局部变量表
       - 8.2.2 操作数栈
       - 8.2.3 动态连接
       - 8.2.4 方法返回地址
       - 8.2.5 附加信息
     - 8.3 方法调用
       - 8.3.1 解析
       - 8.3.2 分派
     - **8.4 动态类型语言支持**
       - 8.4.1 动态类型语言
       - 8.4.2 Java 与动态类型
       - 8.4.3 java.lang.invoker 包
       - 8.4.4 invokedynamic 指令
       - 8.4.5 实战：掌控方法分派规则
     - 8.5 基于栈的字节码解释执行引擎
       - 8.5.1 解释执行
       - 8.5.2 基于栈的指令集与基于寄存器的指令集
       - 8.5.3 基于栈的解释器执行过程
  9. 类加载及其执行子系统的案例与实战
     - 9.2 案例分析
       - 9.2.1 Tomcat：正统的类加载器架构
       - **9.2.2 OSGi：灵活的类加载器架构**
       - 9.2.3 字节码生成技术与动态代理的实现
       - 9.2.4 Backport 工具：Java 的时光机器
     - 9.3 实战：自己动手实现远程执行功能
  10. 前端编译与优化
      - 10.2 Javac 编译器
        - 10.2.1 Javac 的源码与调试
        - 10.2.2 解析与填充符号表
        - 10.2.3 注解处理器
        - 10.2.4 语义分析与字节码生成
      - **10.3 Java 语法糖的味道**
        - **10.3.1 泛型**
        - **10.3.2 自动装箱、拆箱与遍历循环**
        - **10.3.3 条件编译**
      - 10.4 实战：插入式注解处理器
  11. 后端编译与优化
      - 11.2 即时编译器
        - 11.2.1 解释器与编译器
        - 11.2.2 编译对象与触发条件
        - 11.2.3 编译过程
        - 11.2.4 实战：查看及分析即时编译结果
      - 11.3 提前编译器
        - 11.3.1 提前编译的优劣得失
        - 11.3.2 实战：Jaotc 的提前编译
      - **11.4 编译器优化技术**
        - 11.4.1 优化技术概览
        - 11.4.2 方法内联
        - **11.4.3 逃逸分析**
        - 11.4.4 公共子表达式消除
        - 11.4.5 数组边界检查消除
      - 11.5 实战：深入理解 Graal 编译器
        - 11.5.1 历史背景
        - 11.5.2 构建编译调试环境
        - 11.5.3 JVMCI 编译器接口
        - 11.5.4 代码中间表示
        - 11.5.5 代码优化和生成
  12. Java 内存模型与线程
      - 12.2 硬件的效率与一致性
      - **12.3 Java 内存模型**
        - 12.3.2 内存间交互操作
        - 12.3.3 对于 volatile 型变量的特殊规则
        - 12.3.4 针对 long 和 double 型变量的特殊规则
        - 12.3.5 原子性、可见性与有序性
        - **12.3.6 先行发生原则**
      - 12.4 Java 与线程
        - 12.4.1 线程的实现
        - 12.4.2 Java 线程调度
        - 12.4.3 状态转换
      - 12.5 Java 与协程
        - 12.5.1 内核线程的局限
        - 12.5.2 协程的复苏
        - 12.5.3 Java 的解决方案
  13. 线程安全与锁优化
      - 13.2 线程安全
        - 13.2.1 Java 语言中的线程安全
        - 13.2.2 线程安全的实现方法
      - **13.3 锁优化**
        - **13.3.1 自旋锁与自适应自旋**
        - **13.3.2 锁消除**
        - **13.3.3 锁粗化**
        - **13.3.4 轻量级锁**
        - **13.3.5 偏向锁**
- 常考 Java 基础/多线程对应的 JVM 底层实现
  - static
  - final
  - 成员变量、局部变量
  - try-cath-finally
  - try-with-resources
  - 数组
  - 多态
  - 泛型
    - 桥方法
  - 枚举类
  - 内部类
    - $
    - 类 final 变量
  - String
    - intern()
  - 自动装箱/拆箱
  - switch 对枚举和字符串的支持
  - for-each 循环
  - lambda 表达式
  - synchronized
  - volatile

## 内存区域

### 具体问题

- jvm的基本结构
- jvm中那些结构是线程独有和共有的
- jvm 堆栈，区别，线程共享还是线程私有的
- JVM 运行时数据区？
- 在JDK8中移除永久代，并把方法区移至元空间，这么设计的原因是什么 `【2次】`
- **元空间需要进行GC么？需要的话，元空间的GC是young gc还是full gc**
- JVM内存空间分布
- JVM内存结构
- 你对jvm有了解吗？说一下jvm的内存分区？
  堆里面怎么分区的？（这题真不会，只说知道为了方便垃圾回收所以分了新生代区和老年代区，其他的真不知道）
- jvm分区模型
- 首先是模型分成哪几块，堆 栈等等。。
- 哪些是线程私有的哪些是共有的
- 1.6之前和现在1.8哪些地方做了改动(主要是静态区的变化)
- 说一说jvm的分区
- JVM内存结构
- JVM 内存划分， 堆内存分代
- JVM中的内存区域划分，堆的分代，为什么分代， 垃圾回收算法，垃圾回收器
- JVM堆划分，方法区
- JVM 运行时数据区，Synchronized 和 ReentrantLock 区别
- JVM 运行时数据区
- 堆空间怎么分的
- jvm内存分区？常量在哪？变量在哪？堆怎么划分的？
- jvm内存分区，gc发生在哪？
- 数组长度不确定，能在栈上分配内存吗？
- jvm的内存布局和gc过程
- JVM 的内存结构，哪些是线程私有，哪些是线程公有
- JVM 的结构，垃圾收集算法
-  JVM 内存区域
- JVM 的基本结构
- 运行时数据区的基本结构，各种结构都有什么用途
- Jvm 内存结构
- 堆和栈有什么区别
- 堆 和 栈 的区别？
- JVM 内存区域(两次问到，我顺便说了说永生代和元空间，两次面试看面试官表情应该算半拉亮点)
- JVM 的内存划分，各个部分的作用是什么？
- JVM 每个区具有什么功能？
- 元空间是起到什么作用？
- JVM 内存模型，哪些是公有的，哪些是私有的
- 堆是干嘛的，
- 常量池放在方法区和堆上有什么区别，是在更轻量的 GC 上回收
- 介绍一下 JVM 的内存区域？

### 易混点

- 内存模型
  - 是不同的概念。不知道是面经里面作者自己搞不懂，还是面试官自己搞不懂，容易把这两个混为一谈。

### 思考方向

#### 2.2 运行时数据区域

- 方法区、堆、虚拟机栈、本地方法栈、程序计数器

##### 2.2.1 程序计数器

- 线程隔离
  - 因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
- 内容
  - 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
  - 如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）
- 唯一在《Java 虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域

##### 2.2.2 Java 虚拟机栈

- 线程隔离
- 虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
- 局部变量表
  - 内容
    - 存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）
    - 对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）
    - returnAddress 类型（指向了一条字节码指令的地址）
  - 这些数据类型在局部变量表中的存储空间以**局部变量槽（Slot）**来表示
    - 其中 64 位长度的 long 和 double 类型的数据会占用两个变量槽，其余的数据类型只占用一个
  - 局部变量表所需的内存空间在编译期间完成分配
    - 当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小
- 在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况
  - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常
  - 如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常。
    - 具体虚拟机实现是否会抛出对应异常，请参考下面 OOM 专题。
      - **HotSpot 栈在创建线程申请内存以外时就不会 OOM**

##### 2.2.3 本地方法栈

- 线程隔离
- 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务
- **Hot-Spot 虚拟机直接就把本地方法栈和虚拟机栈合二为一**
- 与虚拟机栈一样，也会在栈深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError 异常。
  - 具体虚拟机实现是否会抛出对应异常，请参考下面 OOM 专题。
    - **HotSpot 栈在创建线程申请内存以外时就不会 OOM**

##### 2.2.4 Java 堆

- 所有线程共享
- 是虚拟机所管理的内存中最大的一块。
- 在虚拟机启动时创建。
- 此内存区域的唯一目的就是存放对象实例
  - 即时编译技术：逃逸分析、栈上分配、标量替换 -> Java 对象实例都分配在堆上也渐渐变得不是那么绝对了
- 如果从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。
- 如果在 Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 OutOfMemoryError 异常。

##### 2.2.5 方法区

- 所有线程共享

- 它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据

- 永久代：

  - JDK 8 以前 HostSpot 的实现

    - HotSpot虚拟机设计团队当初选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已
    - BEA JRockit、IBM J9 等没有永久代

  - JDK 6 的时候，HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了

  - JDK 7 的 HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出

  - JDK 8 终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Metaspace）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中

- 如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError 异常

##### 2.2.6 运行时常量池

- **运行时常量池（Runtime Constant Pool）是方法区的一部分。**
- Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
  - 一般来说，除了保存 Class 文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中
- 运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性
  - 运行期间也可以将新的常量放入池中
  - 这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法
- 当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

##### 2.2.7 直接内存

- **并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域**
- 但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现
- NIO
  - 在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式
  - 它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作
  - 这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。
- 内存溢出
  - 显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制
  - 一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常

## 对象的创建

### 具体问题

- 对象创建过程？
- 创建对象一定是在堆上创建吗，每次创建对象都是在堆上申请内存的吗
- 对象的生命周期（new 一个对象的过程）？

### 思考方向

#### 2.3 HotSpot 虚拟机对象探秘

##### 2.3.1 对象的创建

- 文中讨论的对象限于普通 Java 对象，不包括数组和 Class 对象等
- 过程
  - 类加载
    - 当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
  - 分配内存
    - 对象所需内存的大小在类加载完成后便可完全确定
    - 堆内存规整 -> 分配方式：指针碰撞（Serial、ParNew）
    - 堆内存不规整 -> 分配方式：空闲列表（CMS）
    - 垃圾收集器是否有“空间压缩整理”能力决定是否规整
    - 线程安全
      - 可选方案一：CAS
      - 可选方案二：本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）
  - 初始化零值
    - 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值
    - 如果使用了 TLAB 的话，这一项工作也可以提前至 TLAB 分配时顺便进行
  - 进行必要的设置
    - 这些信息存放在对象的对象头（Object Header）之中。
      - 这个对象是哪个类的实例
      - 如何才能找到类的元数据信息
      - 对象的哈希码（实际上对象的哈希码会延后到真正调用 Object::hashCode() 方法时才计算）
      - 对象的GC分代年龄等信息。
    - 根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
  - 从虚拟机的视角来看，一个新的对象已经产生了
    - 但是从 Java 程序的视角看来，对象创建才刚刚开始
      - 构造函数，即 Class 文件中的 `<init>()` 方法还没有执行
      - 所有的字段都为默认的零值
      - 对象需要的其他资源和状态信息也还没有按照预定的意图构造好。
    - new 指令之后会接着执行 `<init>()` 方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来

##### 2.3.2 对象的内存布局

- 对象头

  - 用于存储对象自身的运行时数据（Mark Word）

    - 标志位：锁状态标志

    - 存储内容

      | 存储内容                              | 标志位 | 状态               |
      | ------------------------------------- | ------ | ------------------ |
      | 对象哈希码（HashCode）、对象分代年龄  | 01     | 未锁定             |
      | 指向锁记录的指针                      | 00     | 轻量级锁定         |
      | 指向重量级锁的指针                    | 10     | 膨胀（重量级锁定） |
      | 空，不需要记录信息                    | 11     | GC 标记            |
      | 偏向线程 ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

  - 类型指针

    - 对象指向它的类型元数据的指针

  - 如果对象是一个 Java 数组，还必须有一块用于记录数组长度的数据

    - 因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小
    - 但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小

- 实例数据

  - 是对象真正存储的有效信息
  - 即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来
    - 这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle 参数）和字段在 Java 源码中定义顺序的影响
    - HotSpot虚拟机默认的分配顺序为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放、
    - 在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前

- 对齐填充

  - 任何对象的大小都必须是 8 字节的整数倍

##### 2.3.3 对象的访问定位

- 句柄
  - Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息
  - 好处：reference 中存储的是稳定句柄地址
    - 在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改
- 直接指针
  - Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销
  - 好处：速度更快
    - 它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本
  - HotSpot 主要使用该方式进行对象访问
    - 有例外情况，如果使用了 Shenandoah 收集器的话也会有一次额外的转发

## 内存溢出异常 OOM、内存泄漏

### 具体问题

- JVM OOM 排查？
- 什么会导致栈溢出、堆内存溢出？
- 怎么排查堆溢出
- 说下java里面的OOM
- JVM内存管理和垃圾回收。哪些操作会导致OOM？循环引用怎么解决？
- 内存泄漏，out of memory
- outofmemory，内存泄漏
- outofmemory遇到过没，设置jvm参数吗？
- 那你说说java泄露，可以写一个程序吗？
  （我当初一听第一反应就是终于我这个会了，就回答说： 这个问题很好解决，就说 只要写一个程序 无限创建一个new对象，这个对象是强引用，就可以保证堆被撑破，他说不行，我最后又加了一句，在这个基础上，循环引用，不会被GC，面试官最后说还是不行，其实当初也是慌了，就真的不知道该怎么办了，因为以前看过OOM怎么解决，但是没想过怎么产生OOM，觉得能产生OOM的还被面试官一直否决，最后面试完在网上查才知道，其实应该再加一个条件，就是循环引用的同时，保证一个对象必须是GC root，我当初面试也没尝试再说这一句，只能说紧张加学艺不精）
  评论：是不是问的是内存泄露，而你好像理解成内存溢出惹…？
- 内存溢出的原因 如何排查
- 什么是内存泄漏？什么是内存溢出？什么时候会发生内存泄露
- 什么时候会 OOM，服务 OOM 怎么办，如何排查
- Java 内存泄漏和排查
- 有没有调试过内存溢出的错误？
- 怎么解决内存泄露；
- 什么时候会有内存泄漏，怎么排查

### 思考方向

#### 2.4 实战：OutOfMemoryError 异常

- 除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemoryError（下文称 OOM）异常的可能

##### 2.4.1 Java 堆溢出

- ```
  java.lang.OutOfMemoryError: Java heap space
  ```

- 如何制造 OOM

  - 只要不断地创建对象
  - 保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象
  - 那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生 OOM

- 处理方法

  - 通过内存映像分析工具（如Eclipse Memory Analyzer）对 Dump 出来的堆转储快照进行分析
  - 确认内存中导致 OOM 的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
    - 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些 GC Roots 相关联，才导致垃圾收集器无法回收它们
    - 如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查 Java 虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗
  - 详情见后续调优、工具等内容

##### 2.4.2 虚拟机栈和本地方法栈溢出

- HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈

  - -Xoss 参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的
  - 栈容量只能由 -Xss 参数来设定。

- HotSpot 虚拟机不支持栈的动态扩展

  - 除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError 异常

    - 通过不断建立线程的方式，在 HotSpot 上也是可以产生内存溢出异常的

    - ```
      java.lang.OutOfMemoryError: unable to create native thread
      ```

      - 从 JDK 7 起，以上提示信息中“unable to create native thread”后面，虚拟机会特别注明原因可能是“possiblyout of memory or process/resource limits reached”。

  - 否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致 StackOverflowError 异常。

##### 2.4.3 方法区和运行时常量池溢出

- 运行时常量池是方法区的一部分

- String::intern() 是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象的引用；否则，会将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用

- JDK 6 前的永久代

  - ```
    java.lang.OutOfMemoryError: PermGen space
    ```

  - 在 JDK 6 中，intern() 方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用

    - 而由 StringBuilder 创建的字符串对象 str2 实例在 Java 堆上，所以和对应 str2.intern() 必然不可能是同一个引用

- JDK 7 起字符串常量移至 Java 堆之中

  - ```
    java.lang.OutOfMemoryError: Java heap space
    ```

  - 而 JDK 7（以及部分其他虚拟机，例如 JRockit）的 intern() 方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到 Java 堆中，那只需要在常量池里记录一下首次出现的实例引用即可，因此 intern() 返回的引用和由 StringBuilder 创建的那个字符串实例就是同一个。

- JDK 8 起元空间

  - -XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。
  - -XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。
  - -XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。
  - -XX：MaxMetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。

- 方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。

- 方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件是比较苛刻的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。

##### 2.4.4 本地直接内存溢出

- 直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与 Java 堆最大值（由 -Xmx 指定）一致
- 真正申请分配内存的方法是 Unsafe::allocateMemory()

## 垃圾回收

### 具体问题

- 什么是 gc，gc 怎么排查，怎么手动让 JAVA 虚拟机 OOM
- JVM回收机制，从判断对象死亡、GC Roots、Stop the World、回收算法优缺点讲起，提到引用计数弊端。
- 垃圾回收：年轻代老年代 回收算法 垃圾回收器等
- 问 JVM：GC 如何判断回收的垃圾对象？GC 算法有哪些？Minor Gc 和 Full GC 有什么不同呢？ZGC 垃圾回收器了解吗？
- 讲解一下 JVM 的垃圾回收；

### 思考方向

3 垃圾收集器与内存分配策略

- 3.2 对象已死？
  - 3.2.1 引用计数算法
  - 3.2.2 可达性分析算法
  - 3.2.3 再谈引用
    - 强、软、弱、虚
  - 3.2.4 生存还是死亡？
    - finalize()
  - 3.2.5 回收方法区
    - 方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型
- 3.3 垃圾收集算法
  - 3.3.1 分代收集理论
  - 3.3.2 标记-清除算法
  - 3.3.3 标记-复制算法
  - 3.3.4 标记-整理算法
- 3.4 HotSpot 的算法细节实现
  - 3.4.1 根节点枚举
  - 3.4.2 安全点
    - 有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。
  - 3.4.3 安全区域
    - 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。
  - 3.4.4 记忆集和卡表
    - 垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots 扫描范围
    - 可以用一种称为“卡表”（Card Table）的方式去实现记忆集
      - 记录精度为“卡精度”：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
  - 3.4.5 写屏障
    - 写前屏障
    - 写后屏障
      - 直至 G1 收集器出现之前，其他收集器都只用到了写后屏障
  - 3.4.6 并发的可达性分析
    - 并发扫描过程：三色标记（Tri-color Marking）
    - 并发扫描时对象消失问题的两种解决方案：
      - 增量更新（Incremental Update）
      - 原始快照（Snapshot At The Beginning，SATB）
- **3.5 经典垃圾收集器**
  - 3.5.1 Serial 收集器
  - 3.5.2 ParNew 收集器
  - 3.5.3 Parallel Scavenge 收集器
  - 3.5.4 Serial Old 收集器
  - 3.5.5 Parallel Old 收集器
  - **3.5.6 CMS 收集器**
  - **3.5.7 Garbage First 收集器**
- 3.6 低延迟垃圾收集器
  - **3.6.1 Shenandoah 收集器**
  - **3.6.2 ZGC 收集器**
- 3.7 选择合适的垃圾收集器
  - 3.7.1 Epsilon 收集器
  - 3.7.2 收集器的权衡
  - 3.7.3 虚拟机及垃圾收集器日志
  - 3.7.4 垃圾收集器参数总结
- 3.8 实战：内存分配与回收策略
  - 3.8.1 对象优先在 Eden 分配
  - 3.8.2 大对象直接进入老年代
  - 3.8.3 长期存活的对象将进入老年代
  - 3.8.4 动态对象年龄判定
  - 3.8.5 空间分配担保

### 可达性分析

#### 具体问题

- JVM怎么判断一个对象是否是垃圾对象？
- 说说java里面的gc机制、垃圾回收算法、如何判断一个对象是无用对象？
- 可达性分析
- 再到jvm怎么回收垃圾，说到引用计数和根可达分析，jvm怎么确定根元素
- 判断gcroots的原则是什么
- 哪些可以作为GCROOT（这里太久没看了，没答全）
- root引用和引用计数
- 垃圾回收，怎么判断对象需要回收，垃圾回收机制
- 怎么判断需要垃圾回收？GC Root？
- GC Roots 是什么？主要用来做什么？
- 讲讲垃圾回收和死亡对象判断方法，具体讲讲可达性分析
- JVM,，哪些对象需要回收，垃圾收集算法
- GC 的过程，引用计数法还有在使用吗
- JVM 垃圾回收机制？如何判断需要回收？
- 如何判断一个类是无用的类
- 如何判断一个对象是否该被回收
- Java 引用类型，强软弱虚
- 强引用 弱引用 软引用 虚引用
- java 弱引用和虚引用的区别？
- 四种引用（强、软、弱、虚）
- 说说四种引用
- 场景题：如果是一个服务器用于存储数据，然后里面有一些数据是热点数组，需要缓存，用哪种引用
- JVM中给对象赋值为null，一定会被回收么？举个case，讲到了内存泄露。

#### 思考方向

##### 3.2 对象已死？

###### 3.2.1 引用计数算法

- 很难解决对象之间相互循环引用的问题

###### 3.2.2 可达性分析算法

- 这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的
- GC Roots
  - 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
  - 在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。
  - 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。·在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象。
  - Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
  - 所有被同步锁（synchronized 关键字）持有的对象。
  - 反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。
  - 除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。
    - **分代收集和局部回收（Partial GC）**，如果只针对 Java 堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，**这时候就需要将这些关联区域的对象也一并加入 GC Roots 集合中去**，才能保证可达性分析的正确性。
    - **目前最新的几款垃圾收集器（如 OpenJDK 中的 G1、Shenandoah、ZGC 以及 Azul 的 PGC、C4 这些收集器）无一例外都具备了局部回收的特征**，为了避免GC Roots包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。关于这些概念、优化技巧以及各种不同收集器实现等内容，都将在本章后续内容中一一介绍。

###### 3.2.3 再谈引用

- 在 JDK 1.2 版之后，Java 对引用的概念进行了扩充，将引用分为**强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）**4 种，这 4 种引用强度依次逐渐减弱。
  - **强引用**是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object
    obj=new Object()”这种引用关系
  - **软引用**是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 **SoftReference** 类来实现软引用
  - **弱引用**也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 版之后提供了 **WeakReference** 类来实现弱引用
  - **虚引用**也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 **PhantomReference** 类来实现虚引用

###### 3.2.4 生存还是死亡？

- 即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程
  - 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记
  - 随后进行一次筛选，筛选的条件是此对象是否有必要执行 **finalize()** 方法
    - 假如对象没有覆盖 finalize() 方法，或者 **finalize() 方法已经被虚拟机调用过**，那么虚拟机将这两种情况都视为“没有必要执行”。
    - 如果这个对象被判定为确有必要执行 finalize() 方法，那么该对象将会被放置在一个名为 **F-Queue** 的队列之中，并在稍后由一条由**虚拟机自动建立的、低调度优先级的 Finalizer 线程**去执行它们的 finalize() 方法
      - 这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的 finalize() 方法执行缓慢，或者更极端地发生了死循环，将很可能导致 F-Queue 队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃
    - finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对 F-Queue 中的对象进行第二次小规模的标记，**如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可**，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。
- 并不鼓励大家使用这个方法（ finalize() ）来拯救对象。相反，建议大家尽量避免使用它

###### 3.2.5 回收方法区

- 可以不要求虚拟机在方法区中实现垃圾收集
  - 事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）
- 方法区的垃圾收集主要回收两部分内容
  - 废弃的常量
    - 回收废弃常量与回收 Java 堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，**已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量**。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。
  - 不再使用的类型
    - 条件比较苛刻。需要同时满足下面三个条件：
      - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
      - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。
      - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    - Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“**被允许**”，**而并不是和对象一样，没有引用了就必然会回收**。
      - 关于是否要对类型进行回收，HotSpot虚拟机提供了：
        - -Xnoclassgc参数进行控制
        - 还可以使用 -verbose:class 以及 -XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息
          - 其中 -verbose:class 和 -XX:+TraceClassLoading 可以在 Product 版的虚拟机中使用
          - -XX:+TraceClassUnLoading 参数需要 FastDebug 版的虚拟机支持。
    - 在大量使用反射、动态代理、CGLib 等**字节码框架**，动态生成 JSP 以及 OSGi 这类**频繁自定义类加载器**的场景中，**通常都需要 Java 虚拟机具备类型卸载的能力**，以保证不会对方法区造成过大的内存压力。

### GC 机制、算法

#### 具体问题

- 垃圾回收
- 垃圾回收算法
- 三种回收算法
- 了解JVM吗？为什么需要垃圾回收呢？
- 垃圾回收机制
- 项目中用的哪种垃圾回收机制？
- 项目中用的垃圾回收机制。设置JVM参数
- 回收算法
- 回收算法有哪些具体实现？垃圾回收器
- 讲讲Java GC机制？
- Java的垃圾回收机制
- Java垃圾回收，需要程序员自己回收吗？
- 垃圾回收机制
- GC，新生代为什么要采用复制算法
- GC 的过程，为什么要分代
- gc算法有哪些
- Java怎么进行垃圾回收的？什么对象会进老年代？
- 垃圾回收算法有哪些？为什么新生代使用复制算法？
- jvm的回收算法
- JVM的回收算法，当我背到一半后，打断了，说我知道你是为了面试背背而已，过几天忘了
- gc算法
- jvm的回收策略
- 高吞吐量的话用哪种gc算法
- Full GC
- full gc怎么触发
- FullGC什么时候会发生
- 发生 FULL GC 的条件
- Minor GC 与 Full GC 的触发机制是什么？
- major gc和full gc的区别，我脑抽，说反了，被鄙视了
- 执行了 system.gc(）触发的GC机制，FGC， 如何进行回收的， 分代回收
- 系统周期性卡顿，如何定位问题，结合GC日志， YGC,FGC， 调整分代的大小， 减小FGC时间
- 产生FGC的原因
- full gc问题，怎么排查
- 频繁GC的原因和解决方案
- 什么情况下老年代会发生GC？
- 安全点，安全点的作用？一些 JVM 源码（之前的文章写过，面试官和感兴趣）
- 垃圾回收算法；PS+PO，CMS 为什么要用标记清除算法？CMS 的前身，R 大的文章。
- 垃圾回收机制：场景：计算机性能好 但Idea（也是一个Java程序）但比较卡，原因：可能是因为频繁产生Full GC 怎么排查问题进行调整
- Full GC效果不好 每次只能从90%-》85%之后又90%了，这种情况下应该怎么办比较好   （如果是一次fullgc后，剩余对象不多。那么说明你eden区设置太小，导致短生命周期的对象进入了old区。如果一次fullgc后，old区回收率不大，那么说明old区太小。）
- 垃圾回收算法（标记-清除，标记-复制，标记-整理）
- 垃圾回收策略
- 介绍垃圾回收算法
  介绍复制回收算法
  哪种垃圾回收算法效率最低
  详细介绍标记算法，标记清除流程
- 介绍一下 JVM 的垃圾回收算法？
- Java 垃圾回收的方法新生代和老年代的不同的算法
- 垃圾回收机制讲一下
- 垃圾回收时标记存活对象的三色标记法原理，以及在出现漏标、错标情况时是如何解决的？
- 垃圾回收算法有哪些
- 分别介绍一下 GC 底层算法的优势和劣势以及它们的应用场景；
- 什么是复制算法，他的原理是什么？用在什么区？为什么用在这个区多？
- 标记整理法的缺点是什么？
- 标记复制和标记整理哪个能产生内存碎片（标记整理）

#### 思考方向

##### 3.3 垃圾收集算法

- 从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“**引用计数式垃圾收集**”（Reference Counting GC）和“**追踪式垃圾收集**”（Tracing GC）两大类
  - 这两类也常被称作“**直接垃圾收集**”和“**间接垃圾收集**”。
  - 由于引用计数式垃圾收集算法在本书讨论到的主流 Java 虚拟机中均未涉及，所以我们暂不把它作为正文主要内容来讲解，本节介绍的所有算法均属于**追踪式垃圾收集**的范畴。

###### 3.3.1 分代收集理论

- 它建立在两个分代假说之上：
  - **弱分代假说（Weak Generational Hypothesis）**：绝大多数对象都是朝生夕灭的。
  - **强分代假说（Strong Generational Hypothesis）**：熬过越多次垃圾收集过程的对象就越难以消亡。
- 这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将**回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储**
- 按每次只回收其中某一个或者某些部分的区域划分回收类型
  - **部分收集（Partial GC）**：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：
    - **新生代收集（Minor GC/Young GC）**：指目标只是新生代的垃圾收集。
    - **老年代收集（Major GC/Old GC）**：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
    - **混合收集（Mixed GC）**：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。
  - **整堆收集（Full GC）**：收集整个 Java 堆和方法区的垃圾收集。
- 垃圾收集算法分类：
  - “标记-复制算法”
  - “标记-清除算法”
  - “标记-整理算法”
- 把分代收集理论具体放到现在的商用 Java 虚拟机里，设计者一般至少会把 Java 堆划分为**新生代（Young Generation）**和**老年代（Old Generation）**两个区域
  - HotSpot 的“分代式垃圾收集器框架”。原本 HotSpot 鼓励开发者尽量在这个框架内开发新的垃圾收集器，但除了最早期的两组四款收集器之外，后来的开发者并没有继续遵循。
    - 导致此事的原因有很多，最根本的是分代收集理论仍在不断发展之中，如何实现也有许多细节可以改进，被既定的代码框架约束反而不便
  - 分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。
    - 添加第三条经验法则：
      - **跨代引用假说（Intergenerational Reference Hypothesis）**：跨代引用相对于同代引用来说仅占极少数
    - 依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用
    - 只需在新生代上建立一个全局的数据结构（该结构被称为**“记忆集”，Remembered Set**），这个结构把老年代划分成若干小块，**标识出老年代的哪一块内存会存在跨代引用**。
      - 此后当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。

###### 3.3.2 标记-清除算法

- 最基础的垃圾收集算法
  - 后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。
- 在 1960 年由 Lisp 之父 John McCarthy 所提出
- 算法分为“标记”和“清除”两个阶段：
  - 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象
  - 也可以反过来，标记存活的对象，统一回收所有未被标记的对象。
  - 标记过程就是对象是否属于垃圾的判定过程
- 它的主要缺点有两个
  - 第一个是**执行效率不稳定**，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低
  - 第二个是**内存空间的碎片化问题**，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

###### 3.3.3 标记-复制算法

- 简称为复制算法
- 1969 年 Fenichel 提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法
- 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
  - 如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象
  - 而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。
- 缺点
  - 这种复制回收算法的代价是将**可用内存缩小为了原来的一半**，空间浪费未免太多了一点
- 现在的商用 Java 虚拟机大多都优先采用了这种收集算法去回收新生代
  - IBM 公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有 98% 熬不过第一轮收集。
  - 因此并不需要按照 1∶1 的比例来划分新生代的内存空间。
- 在 1989 年，Andrew Appel 针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。
  - HotSpot 虚拟机的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局
  - Appel 式回收的具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。
  - 发生垃圾搜集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。
  - HotSpot 虚拟机默认 **Eden 和 Survivor 的大小比例是 8∶1**，也即每次新生代中可用内存空间为整个新生代容量的 90%（Eden 的 80% 加上一个 Survivor 的 10%），只有一个 Survivor 空间，即 10% 的新生代是会被“浪费”的。
  - 当然，98% 的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于 10% 的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计
    - 当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行**分配担保（Handle Promotion）**。

###### 3.3.4 标记-整理算法

- 针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法
  - 其中的标记过程仍然与“标记-清除”算法一样
  - 但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存
- 标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。
  - 如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且**这种对象移动操作必须全程暂停用户应用程序才能进行**
    - 这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“**Stop The World**”
  - 但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的**内存分配器和内存访问器**来解决。
    - 譬如通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。
    - 内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。
  - HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法的，而关注延迟的 CMS 收集器则是基于标记-清除算法的，这也从侧面印证这点。
    - 另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的 CMS 收集器面临空间碎片过多时采用的就是这种处理办法。

##### 3.4 HotSpot 的算法细节实现

###### 3.4.1 根节点枚举

- 固定可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中
- **迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的**，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。
- 目前主流 Java 虚拟机使用的都是**准确式垃圾收集**，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，**虚拟机应当是有办法直接得到哪些地方存放着对象引用的**
  - **准确式内存管理（Exact Memory Management，也可以叫 NonConservative/Accurate Memory Management）**是指虚拟机可以知道内存中某个位置的数据具体是什么类型。准确分辨出哪些内存是引用类型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。
- 在 HotSpot 的解决方案里，是使用一组称为 **OopMap** 的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。

###### 3.4.2 安全点

- 可能导致引用关系变化，或者说导致 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂
- 实际上 HotSpot 也的确没有为每条指令都生成 OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为**安全点（Safepoint）**。
  - 有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。
- **安全点位置的选取**基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的
  - 因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行
  - “长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。
- 如何在垃圾收集发生时让所有线程（这里其实不包括执行 JNI 调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：
  - 抢先式中断（Preemptive Suspension）
    - 不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上
    - 现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件
  - 主动式中断（Voluntary Suspension）
    - 思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。
    - 轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在 Java 堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。
    - HotSpot 使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。

###### 3.4.3 安全区域

- 所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入**安全区域（Safe Region）**来解决。
- 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。

###### 3.4.4 记忆集和卡表

- 垃圾收集器在新生代中建立了名为**记忆集（Remembered Set）**的数据结构，用以避免把整个老年代加进GC Roots 扫描范围
  - 事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及**部分区域收集（Partial GC）**行为的垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题
  - 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的**抽象**数据结构
  - 在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。
    - 那设计者在实现记忆集的时候，便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范围以外的）的记录精度：
      - **字长精度**：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
      - **对象精度**：每个记录精确到一个对象，该对象里有字段含有跨代指针。
      - **卡精度**：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
- 其中，第三种“卡精度”所指的是用一种称为**“卡表”（Card Table）**的方式去实现记忆集
  - 这也是目前最常用的一种记忆集实现形式
  - 记忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的具体实现。**卡表就是记忆集的一种具体实现**，它定义了记忆集的记录精度、与堆内存的映射关系等。
  - 卡表最简单的形式可以只是一个**字节数组**，而 HotSpot 虚拟机确实也是这样做的。
    - 字节数组 CARD_TABLE 的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作**“卡页”（Card Page）**。
    - 一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为 1，称为这个元素**变脏（Dirty）**，没有则标识为 0。
    - 在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

###### 3.4.5 写屏障

- 有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。但问题是如何变脏，即**如何在对象赋值的那一刻去更新维护卡表呢**？
  - 假如是**解释执行**的字节码，那相对好处理，虚拟机负责每条字节码指令的执行，有充分的介入空间
  - 但在**编译执行**的场景中呢？经过即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作之中
    - 在 HotSpot 虚拟机里是通过**写屏障（Write Barrier）**技术维护卡表状态的。
      - 注意将这里提到的“写屏障”，以及后面在低延迟收集器中会提到的“读屏障”与解决并发乱序执行问题中的“内存屏障”区分开来，避免混淆。
      - 在赋值前的部分的写屏障叫作**写前屏障（Pre-Write Barrier）**
      - 在赋值后的则叫作**写后屏障（Post-Write Barrier）**。
        - 直至 G1 收集器出现之前，其他收集器都只用到了写后屏障
    - 应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令
      - 一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生**额外的开销**，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。
    - 卡表在高并发场景下还面临着**“伪共享”（False Sharing）**问题
      - 伪共享是处理并发底层细节时一种经常需要考虑的问题
      - 现代中央处理器的缓存系统中是以**缓存行（Cache Line）**为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好**共享同一个缓存行**，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。
      - 一种简单的**解决方案**是不采用无条件的写屏障，而是**先检查卡表标记**，只有当该卡表元素未被标记过时才将其标记为变脏
        - 在 JDK 7 之后，HotSpot 虚拟机增加了一个新的参数 -XX:+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题

###### 3.4.6 并发的可达性分析

- 可达性分析算法理论上要求全过程都基于一个**能保障一致性的快照中**才能够进行分析，这意味着必须全程冻结用户线程的运行。
  - 在**根节点枚举**这个步骤中，由于 GC Roots 相比起整个 Java 堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如 OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。
  - 可**从GC Roots再继续往下遍历对象图**，这一步骤的停顿时间就必定会与 Java 堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长
    - 如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
- **三色标记（Tri-color Marking）**作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“**是否访问过**”这个条件标记成以下三种颜色
  - **白色**：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
  - **黑色**：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
  - **灰色**：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。
- 如果**用户线程与收集器是并发工作**呢？收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果
  - 一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好
  - 另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误
    - Wilson 于 1994 年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：
      - **赋值器插入了一条或多条从黑色对象到白色对象的新引用；**
      - **赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。**
    - 我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：
      - **增量更新（Incremental Update）**
        - 增量更新要破坏的是第一个条件
        - 当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。
        - 这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
      - **原始快照（Snapshot At The Beginning，SATB）**
        - 原始快照要破坏的是第二个条件
        - 当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。
        - 这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

### 内存分配策略

#### 具体问题

- 堆如何分代
- 为什么要分代
- 新生区，老年区分布在那里，说一下他们的区别，和所使用的算法；
- 什么是新生区？什么是老年区？什么是永久代？
- 假设HashMap里面存放100万个对象，那么gc可能会有什么问题？
- byte[] a = new byte[10 * 1024]内存分配过程？多大的对象直接进入老年代？通过什么参数配置？
- 对象什么情况会进去老年代
- 那你知道一个对象怎么从新生代变成老年代吗？（懵逼，对不起，不知道，只简单的知道两个区的定义）
- 介绍 TLAB，PLAB，CAS 分配。
- Eden 和 Survivor 比例可以调整么，参数是什么？还用到了哪些参数？
- JVM 新生代怎么划分，大对象怎么分配
- 怎么释放一个用完的大对象的内存空间？

#### 思考方向

##### 3.8 实战：内存分配与回收策略

###### 3.8.1 对象优先在 Eden 分配

- 大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

###### 3.8.2 大对象直接进入老年代

- 大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组
  - 本节例子中的byte[]数组就是典型的大对象
- 大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，我们写程序的时候应注意避免。
- 在Java虚拟机中要避免大对象的原因
  - 在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们
  - 当复制对象时，大对象就意味着高额的内存复制开销。
- HotSpot 虚拟机提供了 -XX:PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在 Eden 区及两个 Survivor 区之间来回复制，产生大量的内存复制操作。
  - -XX:PretenureSizeThreshold 参数只对 Serial 和 ParNew 两款新生代收集器有效，HotSpot 的其他新生代收集器，如 Parallel Scavenge 并不支持这个参数。

###### 3.8.3 长期存活的对象将进入老年代

- 虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中
- 对象通常在 Eden 区里诞生，如果经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，该对象会被移动到 Survivor 空间中，并且将其对象年龄设为 1 岁。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（**默认为 15**），就会被晋升到老年代中。
- 对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 设置。

###### 3.8.4 动态对象年龄判定

- 为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到 -XX:MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中**相同年龄所有对象大小的总和大于 Survivor 空间的一半**，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 中要求的年龄。

###### 3.8.5 空间分配担保

- 在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许**担保失败（Handle Promotion Failure）**
  - 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
    - 如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；
  - 如果小于，或者 -XX:HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。
- 取历史平均值来比较其实仍然是一种赌概率的解决办法，也就是说假如某次 Minor GC 存活后的对象突增，远远高于历史平均值的话，依然会导致担保失败。
  - 如果出现了担保失败，那就只好老老实实地重新发起一次 Full GC，这样停顿时间就很长了。
  - 虽然担保失败时绕的圈子是最大的，但通常情况下都还是会将 -XX:HandlePromotionFailure 开关打开，避免 Full GC 过于频繁。

##### 栈上分配、TLAB、PLAB

- 栈上分配
  - 对于这些其他线程不会访问的对象，我们能不能让线程自己分配在它自己的栈空间上？这样不就可以节省不少交互时间了
  - 参考后续**逃逸分析**相关
- TLAB
  - TLAB（Thread Local Allocation Buffer），即线程本地分配缓存。这是一块线程专用的内存分配区域，TLAB 占用的是 eden 区的空间。在 TLAB 启用的情况下（默认开启），JVM 会为每一个线程分配一块 TLAB 区域。
- PLAB
  - PLAB（Promotion Local Allocation Buffers），即晋升本地分配缓存。**PLAB 的作用于 TLAB 类似，都是为了加速对象分配效率，避免多线程竞争而诞生的。** 只不过 PLAB 是应用于对象晋升到 Survivor 区或老年代。与 TLAB 类似，每个线程都有独立的 PLAB 区。
- 对象内存分配流程
  - 尝试栈上分配 -> 尝试 TLAB 分配 -> 是否可以直接进入老年代 -> Eden 分配

### 垃圾回收器

#### 具体问题

- 常见的垃圾回收器
- 聊聊垃圾回收，实习的时候团队用的是哪个垃圾收集器？项目用什么垃圾回收器`【2次】`
- 常用的垃圾回收器有哪些？
- 常见的垃圾回收器
- 常见的垃圾回收期
- CMS 垃圾收集器的特性，工作的四个流程，哪几个流程 stop the world
- 讲一讲CMS的回收过程
- 详细介绍下CMS？
- G1和CMS垃圾回收器
- ZGC，聊到了彭寒成的《新一代垃圾回收器 ZGC 设计与实现》和美团技术团队的文章。
- G1
- G1，聊到了中村成洋的《深入 Java 虚拟机：JVM G1GC 的算法与实现》。
- G1，最大的特点，标记位图，卡表卡页，SATB。
- G1的适用场景和实现原理
- 详细说一下Remembered Set的作用，什么时候会往里面写、更新等
- 还有一个Collection Set，你知道C Set的作用是什么吗？
- 常用 GC 算法，常用的垃圾收集器， G1 了解吗
- 垃圾回收器都有哪些
- G1 回收器与之前的回收器相比最大的不同是什么
- 新生代有哪些垃圾回收器
- ParNew 原理
- CMS 收集器收集过程
- 介绍 G1 垃圾收集器、回收过程，与 CMS 对比；
- JVM 垃圾回收器有哪些？
- 讲解一下 Serial 和 CMS，G1 回收器；
- 垃圾回收器、 算法、G1

#### 思考方向

##### 3.5 经典垃圾收集器

- 本节标题中“经典”二字并非情怀，它其实是讨论范围的限定语，这里讨论的是在 JDK 7 Update 4 之后（在这个版本中正式提供了商用的 G1 收集器，此前 G1 仍处于实验状态）、JDK 11 正式发布之前，OracleJDK 中的 HotSpot 虚拟机所包含的全部可用的垃圾收集器。

- 搭配

  - 新生代 Serial + 老年代 CMS（JDK 9 起删除该组合）
  - 新生代 Serial + 老年代 Serial Old(MSC)
  - 新生代 ParNew + 老年代 CMS
  - 新生代 ParNew + 老年代 SerialOld(MSC)（JDK 9 起删除该组合）
  - 新生代 ParallelScavenge + 老年代 SerialOld(MSC)（JDK 14 起弃用（Deprecate）该组合）
  - 新生代 ParallelScavenge + 老年代 Parallel Old
  - G1

###### 3.5.1 Serial 收集器

- Serial 收集器是最基础、历史最悠久的收集器
  - 曾经（在 JDK 1.3.1 之前）是 HotSpot 虚拟机新生代收集器的唯一选择。
  - 单线程工作的收集器
    - 它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，**必须暂停其他所有工作线程，直到它收集结束**。
    - “Stop The World” 这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的
  - Serial/Serial Old 收集器运行逻辑
    - 用户线程都进入安全点后，暂停所有用户线程，**新生代 Serial 采取复制算法**，**单个 GC 线程**进行垃圾回收
    - 然后用户线程再进入安全点后，暂停所有用户线程，**老年代 Serial Old 采取标记-整理算法**，**单个 GC 线程**进行垃圾回收
  - 迄今为止，它依然是HotSpot虚拟机运行在**客户端模式下的默认新生代收集器**，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比）
    - 对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的
    - 对于单核处理器或处理器核心数较少的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

###### 3.5.2 ParNew 收集器

- 实质上是 Serial 收集器的多线程并行版本
  - 除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial收集器完全一致，包括：
    - Serial 收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure 等）
    - 收集算法
    - Stop The World
    - 对象分配规则
    - 回收策略等
  - 在实现上这两种收集器也共用了相当多的代码。
- ParNew / Serial Old 收集器运行逻辑
  - 用户线程都进入安全点后，暂停所有用户线程，**新生代 ParNew 采取复制算法**，**多个 GC 线程**进行垃圾回收
  - 然后用户线程再进入安全点后，暂停所有用户线程，**老年代 Serial Old 采取标记-整理算法**，**单个 GC 线程**进行垃圾回收
- ParNew 收集器除了支持多线程并行收集之外，其他与 Serial 收集器相比并没有太多创新之处，但它却是不少运行在服务端模式下的 HotSpot 虚拟机，尤其是 JDK 7 之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：**除了 Serial 收集器外，目前只有它能与CMS 收集器配合工作**。
  - 在 JDK 5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。
    - CMS 却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作
      - 除了一个面向低延迟一个面向高吞吐量的目标不一致外，技术上的原因是 Parallel Scavenge 收集器及后面提到的 G1 收集器等都**没有使用** HotSpot 中原本设计的垃圾收集器的**分代框架**，而选择另外独立实现。
      - Serial、ParNew 收集器则共用了这部分的框架代码
  - ParNew 收集器是激活 CMS 后（使用 -XX:+UseConcMarkSweepGC 选项）的默认新生代收集器，也可以使用 -XX:+/-UseParNewGC 选项来强制指定或者禁用它。
  - 更先进的 G1 收集器带着 CMS 继承者和替代者的光环登场。G1 是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。
    - 所以自JDK 9开始，ParNew 加 CMS 收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被 G1 所取代（CMS 直接在 9 被弃用（Deprecate）了）
    - 9 甚至还取消了 ParNew 加 Serial Old 以及 Serial 加 CMS 这两组收集器组合的支持（其实原本也很少人这样使用），并直接取消了 -XX:+UseParNewGC 参数，这意味着 ParNew 和 CMS 从此只能互相搭配使用，再也没有其他收集器能够和它们配合了。
    - 读者也可以理解为从此以后，ParNew 合并入 CMS，成为它专门处理新生代的组成部分。ParNew 可以说是 HotSpot 虚拟机中第一款退出历史舞台的垃圾收集器。
- 它默认开启的收集线程数与处理器核心数量相同
  - 可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数
- 从 ParNew 收集器开始，后面还将会接触到若干款涉及“并发”和“并行”概念的收集器。
  - 并行和并发都是并发编程中的专业名词，在谈论垃圾收集器的上下文语境中，它们可以理解为：
  - 并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。
  - 并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

###### 3.5.3 Parallel Scavenge 收集器

- 也是一款新生代收集器
- 基于**标记-复制算法**实现的收集器
- 能够**并行收集的多线程收集器**
- 特点是它的关注点与其他收集器不同，目标是达到一个可控制的吞吐量（Throughput）
  - 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值
  - 如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。
  - 停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。
- 由于与吞吐量关系密切，Parallel Scavenge 收集器也经常被称作“吞吐量优先收集器”。
- 提供了两个参数用于精确控制吞吐量
  - 控制最大垃圾收集停顿时间的 **-XX:MaxGCPauseMillis 参数**
    - -XX:MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。
    - 不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变得更快，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的
      - 系统把新生代调得小一些，收集 300MB 新生代肯定比收集 500MB 快，但这也直接导致垃圾收集发生得更频繁，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。
  - 直接设置吞吐量大小的 **-XX:GCTimeRatio 参数**
    - -XX:GCTimeRatio 参数的值则应当是一个大于 0 小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为 19，那允许的最大垃圾收集时间就占总时间的 5%（即 1/(1+19)），**默认值为 99**，即允许最大 1%（即 1/(1+99)）的垃圾收集时间。
- 除上述两个参数之外，Parallel Scavenge 收集器还有一个**参数 -XX:+UseAdaptiveSizePolicy** 值得我们关注
  - 这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。
  - 如果读者对于收集器运作不太了解，手工优化存在困难的话，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择。
  - **自适应调节策略也是 Parallel Scavenge 收集器区别于 ParNew 收集器的一个重要特性**。

###### 3.5.4 Serial Old 收集器

- 是 Serial 收集器的老年代版本
- 它同样是一个单线程收集器
- 使用**标记-整理**算法
- 主要意义
  - 供客户端模式下的 HotSpot 虚拟机使用。
  - 在服务端模式下，它也可能有两种用途：
    - 一种是在 JDK 5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用
    - 另外一种就是作为 CMS 收集器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。
    - 这两点都将在后面的内容中继续讲解。

###### 3.5.5 Parallel Old 收集器

- 是 Parallel Scavenge 收集器的老年代版本
- 支持**多线程并发收集**
- 基于**标记-整理**算法实现。
- 这个收集器是直到 JDK 6 时才开始提供的。在此之前，新生代的 Parallel Scavenge 收集器一直处于相当尴尬的状态
  - 原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。
  - 由于老年代 Serial Old 收集器在服务端应用性能上的“拖累”，使用 Parallel Scavenge 收集器也未必能在整体上获得吞吐量最大化的效果。
  - Parallel Scavenge + Serial Old 在 JDK 14 中被弃用
- 直到 Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。
- Parallel Scavenge / Parallel Old 收集器运行逻辑
  - 用户线程都进入安全点后，多个 GC 线程进行新生代垃圾回收
  - 然后用户线程再进入安全点后，多个 GC 线程进行老年代垃圾回收

###### 3.5.6 CMS 收集器

- 在 JDK 5 发布时，HotSpot 推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器——CMS 收集器。这款收集器是 HotSpot 虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。
- 在 JDK 9 被弃用，在 JDK 14 被删除
- CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
- 基于**标记-清除算法**实现的
- 运作过程
  - 分为四个步骤，包括：
    - **初始标记（CMS initial mark）**
      - 初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快
    - **并发标记（CMS concurrent mark）**
      - 并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
    - **重新标记（CMS remark）**
      - 而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
        - 参考**增量更新**
      - 这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短
    - **并发清除（CMS concurrent sweep）**
      - 最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。
  - 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。
  - 由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。
- Concurrent Mark Sweep 收集器运行逻辑
  - 多个用户线程 -> Safepoint -> 初始标记 -> Safepoint -> 并发标记（多个用户线程可同时执行）-> Safepoint -> 重新标记 -> Safepoint -> 并发清理（多个用户线程可以同时执行）-> Safepoint -> 重置线程（多个用户线程可同时执行）
- 最主要的优点：
  - 并发收集
  - 低停顿
    - 一些官方公开文档里面也称之为“并发低停顿收集器”（Concurrent Low Pause Collector）
- 至少有以下三个明显的缺点
  - 首先，CMS 收集器对处理器资源非常敏感
    - 事实上，面向并发设计的程序都对处理器资源比较敏感。
    - 在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。
    - CMS 默认启动的回收线程数是**（处理器核心数量 +3）/4**
      - 也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过 25% 的处理器运算资源，并且会随着处理器核心数量的增加而下降。
      - 但是当处理器核心数量不足四个时，CMS 对用户程序的影响就可能变得很大。
    - 为了缓解这种情况，虚拟机提供了一种称为**“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）**的 CMS 收集器变种
      - 所做的事情和以前单核处理器年代 PC 机操作系统靠抢占式多任务来模拟多核并行多任务的思想一样，是在并发标记、清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变慢的时间更多了，但速度下降幅度就没有那么明显。
      - 实践证明增量式的 CMS 收集器效果很一般，从 JDK 7 开始，i-CMS 模式已经被声明为“deprecated”，即已过时不再提倡用户使用，到 JDK 9 发布后 iCMS 模式被完全废弃。
  - 然后，由于 CMS 收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的 Full GC 的产生。
    - 在 CMS 的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS 无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。
    - 同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要**预留足够内存空间提供给用户线程使用**，因此 CMS 收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。
      - 在 JDK 5 的默认设置下，CMS 收集器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置
      - 到了 JDK 6 时，**CMS 收集器的启动阈值就已经默认提升至 92%**。
        - 但这又会更容易面临另一种风险：要是 CMS 运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure）
        - 这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。
        - 适当调整参数 -XX:CMSInitiatingOccupancyFraction 的值来修改 CMS 的触发百分比，用户应在生产环境中根据实际应用情况来权衡设置。
  - 最后一个缺点，CMS 是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生
    - 空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。
    - 为了解决这个问题
      - CMS 收集器提供了一个 **-XX:+UseCMSCompactAtFullCollection** 开关参数（默认是开启的，此参数从 JDK 9 开始废弃），用于在 CMS 收集器不得不进行 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在 Shenandoah 和 ZGC 出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长
      - 因此虚拟机设计者们还提供了另外一个参数 **-XX:CMSFullGCsBeforeCompaction**（此参数从 JDK 9 开始废弃），这个参数的作用是要求 CMS 收集器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。

###### 3.5.7 Garbage First 收集器

- Garbage First（简称 G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。

  - 至 JDK 7 Update 4，Oracle 才认为它达到足够成熟的商用程度，移除了“Experimental”的标识；
  - 到了 JDK 8 Update 40 的时候，G1 提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。这个版本以后的 G1 收集器才被 Oracle 官方称为“全功能的垃圾收集器”（Fully-Featured Garbage Collector）。

- JDK 9 发布之日，G1 宣告取代 Parallel Scavenge 加 Parallel Old 组合，成为**服务端模式下的默认垃圾收集器**，而 CMS 则沦落至被声明为不推荐使用（Deprecate）的收集器

- 设计者们希望做出一款能够建立起“停顿时间模型”（Pause Prediction Model）的收集器

  - 停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是实时Java（RTSJ）的中软实时垃圾收集器特征了。

- 它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称 CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 Mixed GC 模式。

- G1 开创的基于 Region 的堆内存布局是它能够实现这个目标的关键。

  - 虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。
  - 收集器能够对扮演不同角色的 Region 采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。
  - Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。
    - G1认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。每个 Region 的大小可以通过参数 -XX:G1HeapRegionSize 设定，取值范围为 1MB～32MB，且应为 2 的 N 次幂。
    - 而对于那些超过了整个 Region 容量的超级大对象，将会被存放在 N 个连续的 Humongous Region 之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待

- 虽然 G1 仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。

- G1 收集器之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。

  - 更具体的处理思路是让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的“价值”大小
    - 价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数 -XX：MaxGCPauseMillis 指定，默认值是 200 毫秒），优先处理回收价值收益最大的那些 Region，这也就是“Garbage First”名字的由来。
    - 这种使用 Region 划分内存空间，以及具有优先级的区域回收方式，保证了 G1 收集器在有限的时间内获取尽可能高的收集效率。

- G1将堆内存“化整为零”的“解题思路”至少有（不限于）以下这些关键的细节问题需要妥善解决：

  - 譬如，将 Java 堆分成多个独立 Region 后，Region 里面存在的**跨 Region 引用对象如何解决**？
    - 使用记忆集避免全堆作为 GC Roots 扫描
      - 在 G1 收集器上记忆集的应用其实要复杂很多，它的每个 Region 都维护有自己的记忆集，这些记忆集会记录下别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内
      - G1 的记忆集在存储结构的本质上是一种哈希表，Key 是别的 Region 的起始地址，Value 是一个集合，里面存储的元素是卡表的索引号。
      - 这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于 Region 数量比传统收集器的分代数量明显要多得多，因此 G1 收集器要比其他的传统垃圾收集器有着更高的内存占用负担。
        - 根据经验，G1 至少要耗费大约相当于Java堆容量 10% 至 20% 的额外内存来维持收集器工作。
  - 譬如，在并发标记阶段如何保证**收集线程与用户线程互不干扰**地运行？
    - 这里首先要解决的是用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误，该问题的解决办法笔者已经抽出独立小节来讲解过
      - CMS 收集器采用**增量更新**算法实现
      - 而 G1 收集器则是通过**原始快照**（SATB）算法来实现的
    - 此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1 为每一个 Region 设计了两个名为 TAMS（Top at Mark Start）的指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上
      - G1 收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。
    - 与 CMS 中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1 收集器也要被迫冻结用户线程执行，导致 Full GC 而产生长时间“Stop The World”。
  - 譬如，怎样建立起**可靠的停顿预测模型**？
    - 用户通过 -XX:MaxGCPauseMillis 参数指定的停顿时间只意味着垃圾收集发生之前的期望值，但 G1 收集器要怎么做才能满足用户的期望呢？
    - G1 收集器的停顿预测模型是以**衰减均值（Decaying Average）**为理论基础来实现的，在垃圾收集过程中，G1 收集器会记录每个 Region 的回收耗时、每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。
      - 这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。
      - Region 的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些 Region 组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。

- 如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1 收集器的运作过程大致可划分为以下四个步骤：

  - **初始标记（Initial Marking）**：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。
  - **并发标记（Concurrent Marking）**：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。
  - **最终标记（Final Marking）**：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。
  - **筛选回收（Live Data Counting and Evacuation）**：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

- G1 收集器运行逻辑

  - 多个用户线程 -> Safepoint -> 初始标记 -> Safepoint -> 并发标记（多个用户线程可同时执行）-> Safepoint -> 最终标记 -> 筛选回收 -> Safepoint -> 

- 从上述阶段的描述可以看出，G1 收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才能担当起“全功能收集器”的重任与期望

- 毫无疑问，可以由用户指定期望的停顿时间是 G1 收集器很强大的一个功能，设置不同的期望停顿时间，可使得 G1 在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。

  - 不过，这里设置的“期望值”必须是符合实际的，不能异想天开，毕竟 G1 是要冻结用户线程来复制对象的，这个停顿时间再怎么低也得有个限度。
  - 它默认的停顿目标为**两百毫秒**
    - 一般来说，回收阶段占到几十到一百甚至接近两百毫秒都很正常，但如果我们把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。
    - 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间，但应用运行时间一长就不行了，最终占满堆引发Full GC反而降低性能，所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。

- 从 G1 开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率（Allocation Rate），而不追求一次把整个 Java 堆全部清理干净。

  - 这种新的收集器设计思路从工程实现上看是从 G1 开始兴起的，所以说 G1 是收集器技术发展的一个里程碑。

- 与 CMS 收集器互相比较

  - 可以指定最大停顿时间、分 Region 的内存布局、按收益动态确定回收集这些创新性设计带来的红利

  - 从最传统的算法理论上看，G1 也更有发展潜力。

    - 与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个 Region 之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。
    - 这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。

  - 比起 CMS，G1 的弱项也可以列举出不少：

    如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。

    - 就内存占用来说，虽然 G1 和 CMS 都使用卡表来处理跨代指针，但 G1 的卡表实现更为复杂，而且堆中每个 Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致 G1 的记忆集（和其他内存消耗）可能会占整个堆容量的 20% 乃至更多的内存空间；
      - 相比起来 CMS 的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的
    - 在执行负载的角度上，同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同
      - 譬如它们都使用到写屏障，CMS 用写后屏障来更新维护卡表；而 G1 除了使用写后屏障来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。
        - 相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免 CMS 那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。
      - 由于 G1 对写屏障的复杂操作要比 CMS 消耗更多的运算资源，所以 CMS 的写屏障实现是直接的同步操作，而 G1 就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。

  - 以上的优缺点对比仅仅是针对 G1 和 CMS 两款垃圾收集器单独某方面的实现细节的定性分析，下面是针对具体场景才能做的定量比较：

    - 按照笔者的实践经验，目前在小内存应用上 CMS 的表现大概率仍然要会优于 G1
    - 而在大内存应用上 G1 则大多能发挥其优势
    - 这个优劣势的 Java 堆容量平衡点通常在 6GB 至 8GB 之间，当然，以上这些也仅是经验之谈
    - 随着HotSpot的开发者对 G1 的不断优化，也会让对比结果继续向 G1 倾斜。（注：JDK 14 CMS 直接没了，笑）

##### 3.6 低延迟垃圾收集器

- 衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”。

  - 在内存占用、吞吐量和延迟这三项指标里，延迟的重要性日益凸显，越发备受关注。
    - 其原因是随着计算机硬件的发展、性能的提升，我们越来越能容忍收集器多占用一点点内存；
    - 硬件性能增长，对软件系统的处理能力是有直接助益的，硬件的规格和性能越高，也有助于降低收集器运行时对应用程序的影响，换句话说，吞吐量会更高。
    - 但对延迟则不是这样，硬件规格提升，准确地说是内存的扩大，对延迟反而会带来负面的效果
      - 虚拟机要回收完整的 1TB 的堆内存，毫无疑问要比回收 1GB 的堆内存耗费更多时间

###### 3.6.1 Shenandoah 收集器

- Shenandoah作为第一款不由 Oracle（包括以前的 Sun）公司的虚拟机团队所领导开发的 HotSpot 垃圾收集器，不可避免地会受到一些来自“官方”的排挤。

  - Oracle 仍明确拒绝在 Oracle JDK 12 中支持 Shenandoah 收集器

- 最初 Shenandoah 是由 RedHat 公司独立发展的新型收集器项目，在 2014 年 RedHat 把 Shenandoah 贡献给了 OpenJDK，并推动它成为 OpenJDK 12 的正式特性之一，也就是后来的 JEP 189。

- 这个项目的目标是实现一种能在**任何堆内存大小下**都可以把垃圾收集的**停顿时间限制在十毫秒**以内的垃圾收集器

  - 该目标意味着相比 CMS 和 G1，Shenandoah 不仅要进行并发的垃圾标记，还要并发地进行对象清理后的整理动作。

- 从代码历史渊源上讲，比起稍后要介绍的有着 Oracle 正朔血统的 ZGC，Shenandoah 反而更像是 G1 的下一代继承者，它们两者有着相似的堆内存布局，在初始标记、并发标记等许多阶段的处理思路上都高度一致，甚至还直接共享了一部分实现代码

  - 这使得部分对 G1 的打磨改进和 Bug 修改会同时反映在 Shenandoah 之上
  - 而由于 Shenandoah 加入所带来的一些新特性，也有部分会出现在 G1 收集器中，譬如在并发失败后作为“逃生门”的 Full GC，G1 就是由于合并了 Shenandoah 的代码才获得多线程 Full GC 的支持。

- 那 Shenandoah 相比起 G1 又有什么改进呢？

  - 虽然 Shenandoah 也是使用基于 Region 的堆内存布局，同样有着用于存放大对象的 Humongous Region，默认的回收策略也同样是优先处理回收价值最大的 Region……
  - 但在管理堆内存方面，它与 G1 至少有三个明显的不同之处
    - 最重要的当然是支持并发的整理算法，G1的回收阶段是可以多线程并行的，但却不能与用户线程并发，这点作为Shenandoah最核心的功能稍后笔者会着重讲解。
    - 其次，Shenandoah（目前）是**默认不使用分代收集**的，换言之，不会有专门的新生代 Region 或者老年代 Region 的存在，没有实现分代，并不是说分代对 Shenandoah 没有价值，这更多是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上。
    - 最后，Shenandoah 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为“**连接矩阵”（Connection Matrix）**的全局数据结构来记录跨 Region 的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题（见3.4.4节）的发生概率。
      - 连接矩阵可以简单理解为一张二维表格，如果 Region N 有对象指向 Region M，就在表格的 N 行 M 列中打上一个标记

- Shenandoah收集器的**工作过程**大致可以划分为以下九个阶段

  （此处以 Shenandoah 在 2016 年发表的原始论文进行介绍。在最新版本的 Shenandoah 2.0 中，进一步强化了“部分收集”的特性，初始标记之前还有 Initial Partial、Concurrent Partial 和 Final Partial 阶段，它们可以不太严谨地理解为对应于以前分代收集中的 Minor GC 的工作）：

  - **初始标记（Initial Marking）**：与 G1 一样，首先标记与 GC Roots 直接关联的对象，这个阶段仍是**“Stop The World”**的，但停顿时间与堆大小无关，只与 GC Roots 的数量相关。
  - **并发标记（Concurrent Marking）**：与 G1 一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。
  - **最终标记（Final Marking）**：与 G1 一样，处理剩余的 SATB 扫描，并在这个阶段统计出回收价值最高的 Region，将这些 Region 构成一组回收集（Collection Set）。最终标记阶段也会有一小段**短暂的停顿**。
  - **并发清理（Concurrent Cleanup）**：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的 Region（这类 Region 被称为 Immediate Garbage Region）。
  - **并发回收（Concurrent Evacuation）**：并发回收阶段是 Shenandoah 与之前 HotSpot 中其他收集器的核心差异。在这个阶段，Shenandoah 要把回收集里面的存活对象先复制一份到其他未被使用的 Region 之中。
    - 复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。
      - 其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。
    - 对于并发回收阶段遇到的这些困难，Shenandoah 将会通过读屏障和被称为**“Brooks Pointers”**的转发指针来解决（讲解完 Shenandoah 整个工作过程之后笔者还要再回头介绍它）。
    - 并发回收阶段运行的时间长短取决于回收集的大小。
  - **初始引用更新（Initial Update Reference）**：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。
    - 引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。
    - 初始引用更新时间很短，会产生一个**非常短暂的停顿**。
  - **并发引用更新（Concurrent Update Reference）**：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。
    - 并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
  - **最终引用更新（Final Update Reference）**：解决了堆中的引用更新后，还要修正存在于 GC Roots 中的引用。
    - 这个阶段是 Shenandoah 的**最后一次停顿**，停顿时间只与 GC Roots 的数量相关。
  - **并发清理（Concurrent Cleanup）**：经过并发回收和引用更新之后，整个回收集中所有的 Region 已再无存活对象，这些 Region 都变成 Immediate Garbage Regions 了，最后再调用一次并发清理过程来回收这些 Region 的内存空间，供以后新对象分配使用。

- 以上对 Shenandoah 收集器这九个阶段的工作过程的描述可能拆分得略为琐碎，读者只要抓住其中三个最重要的并发阶段（并发标记、并发回收、并发引用更新），就能比较容易理清 Shenandoah 是如何运作的了。

- Shenandoah 的**弱项（高运行负担使得吞吐量下降）**和**强项（低延迟时间）**

- Brooks Pointer 详解

  - 1984 年，Rodney A.Brooks 在论文《Trading Data Space for Reduced Time and Code Space in Real-Time Garbage Collection on Stock Hardware》中提出了使用转发指针（Forwarding Pointer，也常被称为 Indirection Pointer）来实现对象移动与用户程序并发的一种解决方案。
    - 此前，要做类似的并发操作，通常是在被移动对象原有的内存上设置保护陷阱（Memory Protection Trap），一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中段，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上。
    - 虽然确实能够实现对象移动与用户线程并发，但是如果没有操作系统层面的直接支持，这种方案将导致用户态频繁切换到核心态，代价是非常大的，不能频繁使用。
  - Brooks提出的新方案不需要用到内存保护陷阱，而是在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，**该引用指向对象自己**
    - 从结构上来看，Brooks 提出的转发指针与某些早期 Java 虚拟机使用过的句柄定位（参考对象定位）有一些相似之处
      - 两者都是一种间接性的对象访问方式，差别是句柄通常会统一存储在专门的句柄池中，而转发指针是分散存放在每一个对象头前面。
    - 缺点
      - 每次对象访问会带来一次额外的转向开销
    - 收益
      - 当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上
    - 问题
      - Brooks 形式的转发指针在设计上决定了它是必然会出现**多线程竞争问题**的
        - 实际上 Shenandoah 收集器是通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。
      - **执行频率的问题**
        - 尽管通过对象头上的Brooks Pointer 来保证并发时原对象与复制对象的访问一致性，这件事情只从原理上看是不复杂的，但是“对象访问”这四个字的分量是非常重的
          - 对于一门面向对象的编程语言来说，对象的读取、写入，对象的比较，为对象哈希值计算，用对象加锁等，这些操作都属于对象访问的范畴，它们在代码中比比皆是
        - 要覆盖全部对象访问操作，Shenandoah 不得不同时设置读、写屏障去拦截。
          - 为了实现 Brooks Pointer，Shenandoah 在读、写屏障中都加入了额外的转发处理，尤其是使用读屏障的代价，这是比写屏障更大的。
          - 代码里对象读取的出现频率要比对象写入的频率高出很多，读屏障数量自然也要比写屏障多得多，所以读屏障的使用必须更加谨慎，不允许任何的重量级操作。
          - 计划在 JDK 13 中将Shenandoah的内存屏障模型改进为基于引用访问屏障（Load Reference Barrier）的实现（注：不确定最后是否在这个版本落地了）
            - 所谓“引用访问屏障”是指内存屏障只拦截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写，这能够省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗。

###### 3.6.2 ZGC 收集器

- ZGC（“Z”并非什么专业名词的缩写，这款收集器的名字就叫作 Z Garbage Collector）是一款在 JDK 11 中新加入的具有实验性质的低延迟垃圾收集器，是由 Oracle 公司研发的。（注：JDK 15 和 Shenandoah 一起进入产品阶段）
- ZGC 和 Shenandoah 的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。
- 但是 ZGC 和 Shenandoah 的实现思路又是差异显著的
  - 如果说 RedHat 公司开发的 Shenandoah 像是 Oracle 的 G1 收集器的实际继承者的话
  - 那 Oracle 公司开发的ZGC就更像是 Azul System 公司独步天下的 PGC（Pauseless GC）和 C4（Concurrent Continuously CompactingCollector）收集器的同胞兄弟。
    - 早在 2005 年，运行在 Azul VM 上的 PGC 就已经实现了标记和整理阶段都全程与用户线程并发运行的垃圾收集，而运行在 Zing VM 上的 C4 收集器是 PGC 继续演进的产物，主要增加了分代收集支持，大幅提升了收集器能够承受的对象分配速度。
- 主要特征：ZGC 收集器是一款**基于 Region 内存布局**的，（暂时）**不设分代的**，使用了**读屏障、染色指针和内存多重映射**等技术来实现**可并发的标记-整理**算法的，以**低延迟**为首要目标的一款垃圾收集器。
  - 首先从 ZGC 的**内存布局**说起。
    - 与 Shenandoah 和 G1 一样，ZGC 也采用基于 Region 的堆内存布局，但与它们不同的是， ZGC 的 Region（在一些官方资料中将它称为 Page 或者 ZPage，本章为行文一致继续称为 Region）具有**动态性**——动态创建和销毁，以及动态的区域容量大小。在 x64 硬件平台下，ZGC 的 Region 可以具有的大、中、小三类容量：
      - 小型 Region（Small Region）：容量固定为 2MB，用于放置小于 256KB 的小对象。
      - 中型 Region（Medium Region）：容量固定为 32MB，用于放置大于等于 256KB 但小于 4MB 的对象。
      - 大型 Region（Large Region）：容量不固定，可以动态变化，但必须为 2MB 的整数倍，用于放置 4MB 或以上的大对象。每个大型 Region 中只会存放一个大对象，这也预示着虽然名字叫作“大型 Region”，但它的实际容量完全有可能小于中型 Region，最小容量可低至 4MB。大型 Region 在 ZGC 的实现中是不会被重分配（重分配是 ZGC 的一种处理动作，用于复制对象的收集器阶段，稍后会介绍到）的，因为复制一个大对象的代价非常高昂。
  - 接下来是 ZGC 的核心问题——**并发整理算法**的实现。
    - ZGC 收集器有一个标志性的设计是它采用的染色指针技术（Colored Pointer，其他类似的技术中可能将它称为 Tag Pointer 或者 Version Pointer）。
      - 从前，如果我们要在对象上存储一些额外的、只供收集器或者虚拟机本身使用的数据，通常会在对象头中增加额外的存储字段
      - HotSpot 虚拟机的几种收集器有不同的标记实现方案，有的把标记直接记录在对象头上（如 Serial 收集器），有的把标记记录在与对象相互独立的数据结构上（如 G1、Shenandoah 使用了一种相当于堆内存的 1/64 大小的，称为 BitMap 的结构来记录标记信息），而 ZGC 的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上，这时，与其说可达性分析是遍历对象图来标记对象，还不如说是遍历“引用图”来标记“引用”了。
      - 染色指针是一种直接将少量额外的信息存储在指针上的技术，可是为什么指针本身也可以存储额外信息呢？
        - 尽管 Linux 下 64 位指针的高 18 位不能用来寻址，但剩余的 46 位指针所能支持的 64TB 内存在今天仍然能够充分满足大型服务器的需要。
        - 鉴于此，ZGC 的染色指针技术继续盯上了这剩下的 46 位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过 finalize() 方法才能被访问到
        - 当然，由于这些标志位进一步压缩了原本就只有 46 位的地址空间，也直接导致 ZGC 能够管理的内存不可以超过 4TB（2 的 42 次幂）
      - 诸多约束
        - 染色指针有 4TB 的内存限制
        - 不能支持 32位平台
        - 不能支持压缩指针（-XX:+UseCompressedOops）等
      - 三大优势
        - 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。
        - 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。实际上，到目前为止ZGC都并未使用任何写屏障，只使用了读屏障（一部分是染色指针的功劳，一部分是ZGC现在还不支持分代收集，天然就没有跨代引用的问题）。
        - 染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。
      - 不过，要顺利应用染色指针有一个必须解决的前置问题：Java虚拟机作为一个普普通通的进程，这样随意重新定义内存中某些指针的其中几位，操作系统是否支持？处理器是否支持？这是很现实的问题，无论中间过程如何，程序代码最终都要转换为机器指令流交付给处理器去执行，处理器可不会管指令流中的指针哪部分存的是标志位，哪部分才是真正的寻址地址，只会把整个指针都视作一个内存地址来对待。
        - Linux/x86-64 平台上的 ZGC 使用了**多重映射（Multi-Mapping）**将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射，意味着 ZGC 在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。
  - ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段，这些小阶段，譬如初始化GC Root直接关联对象的Mark Start
    - **并发标记（Concurrent Mark）**：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记（尽管ZGC中的名字不叫这些）的短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。
      - 与G1、Shenandoah不同的是，ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。
    - **并发预备重分配（Concurrent Prepare for Relocate）**：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成**重分配集（Relocation Set）**。
      - 重分配集与G1收集器的回收集（Collection Set）还是有区别的，ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。
      - 因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。
      - 此外，在 JDK 12 的 ZGC 中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。
    - **并发重分配（Concurrent Relocate）**：重分配是ZGC执行过程中的核心阶段，
      - 这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个**转发表（Forward Table）**，记录从旧对象到新对象的转向关系。
      - 得益于染色指针的支持，ZGC 收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据 Region 上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的**“自愈”（Self Healing）**能力。
        - 这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次，对比Shenandoah 的 Brooks 转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢，因此 ZGC 对用户程序的运行时负载要比 Shenandoah 来得更低一些。
        - 还有另外一个直接的好处是由于染色指针的存在，一旦重分配集中某个 Region 的存活对象都复制完毕后，这个 Region 就可以立即释放用于新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的。
    - **并发重映射（Concurrent Remap）**：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与 Shenandoah 并发引用更新阶段一样的，但是 ZGC的并发重映射并不是一个必须要“迫切”去完成的任务
      - 因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。
      - 因此，ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。
- ZGC的设计理念与Azul System公司的PGC和C4收集器一脉相承[10]，是迄今垃圾收集器研究的最前沿成果，它与Shenandoah一样做到了几乎整个收集过程都全程可并发，短暂停顿也只与GC Roots大小相关而与堆内存大小无关，因而同样实现了任何堆上停顿都小于十毫秒的目标。
- 相比G1、Shenandoah等先进的垃圾收集器，ZGC在实现细节上做了一些不同的权衡选择
  - 譬如G1需要通过写屏障来维护记忆集，才能处理跨代指针，得以实现Region的增量回收。记忆集要占用大量的内存空间，写屏障也对正常程序运行造成额外负担，这些都是权衡选择的代价。
  - ZGC就完全没有使用记忆集，它甚至连分代都没有，连像CMS中那样只记录新生代和老年代间引用的卡表也不需要，因而完全没有用到写屏障，所以给用户线程带来的运行负担也要小得多。
    - ZGC的这种选择也限制了它能承受的对象分配速率不会太高
- ZGC还有一个常在技术资料上被提及的优点是支持“NUMA-Aware”的内存分配。
  - NUMA（Non Uniform Memory Access，非统一内存访问架构）是一种为多处理器或者多核处理器的计算机所设计的内存架构。
  - 在NUMA架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。
  - 在ZGC之前的收集器就只有针对吞吐量设计的Parallel Scavenge支持NUMA内存分配，如今ZGC也成为另外一个选择。

##### 3.7 选择合适的垃圾收集器

###### 3.7.1 Epsilon 收集器

- JDK 11
- 这是一款以不能够进行垃圾收集为“卖点”的垃圾收集器
- Epsilon收集器由RedHat公司在JEP 318中提出，在此提案里Epsilon被形容成一个无操作的收集器（A No-Op Garbage Collector），而事实上只要Java虚拟机能够工作，垃圾收集器便不可能是真正“无操作”的。
  - 原因是“垃圾收集器”这个名字并不能形容它全部的职责，更贴切的名字应该是本书为这一部分所取的标题——“自动内存管理子系统”。
  - 一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负责堆的管理与布局、对象的分配、与解释器的协作、与编译器的协作、与监控子系统协作等职责，其中至少堆的管理和对象的分配这部分功能是Java虚拟机能够正常运作的必要支持，是一个最小化功能的垃圾收集器也必须实现的内容。
- 从 JDK 10 开始，为了隔离垃圾收集器与 Java 虚拟机解释、编译、监控等子系统的关系，RedHat 提出了垃圾收集器的统一接口，即 JEP 304 提案，Epsilon 是这个接口的有效性验证和参考实现，同时也用于需要剥离垃圾收集器影响的性能测试和压力测试。

###### 3.7.2 收集器的权衡

- 我们应该如何选择一款适合自己应用的收集器呢？这个问题的答案主要受以下三个因素影响
  - 应用程序的主要关注点是什么？如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那**吞吐量**就是主要关注点；如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样**延迟**就是主要关注点；而如果是客户端应用或者嵌入式应用，那垃圾收集的**内存占用**则是不可忽视的。
  - 运行应用的基础设施如何？譬如硬件规格，要涉及的系统架构是 x86-32/64、SPARC 还是 ARM/Aarch64；处理器的数量多少，分配内存的大小；选择的操作系统是 Linux、Solaris 还是Windows 等。
  - 使用 JDK 的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？

###### 3.7.3 虚拟机及垃圾收集器日志

- 在 JDK 9 以前，HotSpot 并没有提供统一的日志处理框架，虚拟机各个功能模块的日志开关分布在不同的参数上，日志级别、循环日志大小、输出格式、重定向等设置在不同功能上都要单独解决。
- 直到 JDK 9，这种混乱不堪的局面才终于消失，HotSpot所有功能的日志都收归到了“-Xlog”参数上，这个参数的能力也相应被极大拓展了

###### 3.7.4 垃圾收集器参数总结

| 参数                            | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| UseSerialGC                     | **虚拟机运行在 Client 模式下的默认值**，打开此开关后，使用 Serial + Serial Old 的收集器组合进行内存回收 |
| UseParNewGC                     | 打开此开关后，使用 ParNew + Serial Old 的收集器组合进行内存回收，在 JDK 9 后不再支持 |
| UseConcMarkSweepGC              | 打开此开关后，使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收。Serial Old 收集器将作为 CMS 收集器出现“Concurrent Mode Failure”失败后的后备收集器使用 |
| UseParallelGC                   | **JDK 9 之前虚拟机运行在 Server 模式下的默认值**，打开此开关后，使用 Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收 |
| UseParallelOldGC                | 打开此开关后，使用 Parallel Scavenge + Parallel Old 的收集器组合进行内存回收（**注：有文章说实际上 Java 7u4 之后，包括 8，Server 模式下默认是这个组合了**） |
| SurvivorRatio                   |                                                              |
| PretenureSizeThreshold          |                                                              |
| MaxTenuringThreshold            |                                                              |
| UseAdaptiveSizePolicy           |                                                              |
| HandlePromotionFailure          |                                                              |
| ParallelGCThreads               |                                                              |
| GCTimeRatio                     |                                                              |
| MaxGCPauseMillis                |                                                              |
| CMSInitiating OccupancyFraction |                                                              |
| UseCMSCompactAtFullCollection   |                                                              |
| CMSFullGCsBeforeCompaction      |                                                              |
| UseG1GC                         |                                                              |
| G1HeapRegionSize=n              |                                                              |
| MaxGCPauseMillis                |                                                              |
| G1NewSizePercent                |                                                              |
| G1MaxNewSizePercent             |                                                              |
| ParallelGCThreads               |                                                              |
| ConcGCThreads=n                 |                                                              |
| InitiatingHeapOccupancyPercent  |                                                              |
| UseShenandoahGC                 |                                                              |
| ShenandoahGCHeuristics          |                                                              |
| UseZGC                          |                                                              |
| UseNUMA                         |                                                              |

## 虚拟机性能监控、故障处理工具

### 具体问题

- JVM相关的分析工具有使用过哪些？具体的性能调优步骤吗？
- 说一下垃圾回收？如果GC突然很慢怎么排查，比如原来GC完成只需要1秒，现在要5秒？了解哪些gc相关的工具，比如jstack之类的
- 有没有用过工具，怎么查看Java堆的统计信息 (参考《深入理解Java虚拟机》第4章，没用过工具，只说了常用了JVM参数)
- jvm工具，jstack jconsole 这些，还是看一丢丢，留个印象
- 服务器CPU使用率很高，如何排查， top 定位进程， 如果是Java，通过jstack进行线程快照分析，jmap，jhat 等等，
- 用到过内存分析工具吗；
- 查看运行内存，JVM 状态有什么方法

### 思考方向

#### 4.2 基础故障处理工具

- Java 开发人员肯定都知道 JDK 的 bin 目录中有 java.exe、javac.exe 这两个命令行工具，但并非所有程序员都了解过 JDK 的 bin 目录下其他各种小工具的作用。
  - 除了编译和运行 Java 程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到它们
- 在本章，笔者将介绍这些工具中的一部分，主要是用于监视虚拟机运行状态和进行故障处理的工具。
  - 这些故障处理工具根据软件可用性和授权的不同，可以把它们划分成三类：
    - 商业授权工具：主要是JMC（Java Mission Control）及它要使用到的JFR（Java Flight Recorder），JMC 这个原本来自于 JRockit 的运维监控套件从 JDK 7 Update 40 开始就被集成到 OracleJDK 中，JDK 11之前都无须独立下载，但是在商业环境中使用它则是要付费的
    - 正式支持工具：这一类工具属于被长期支持的工具，不同平台、不同版本的JDK之间，这类工具可能会略有差异，但是不会出现某一个工具突然消失的情况
    - 实验性工具：这一类工具在它们的使用说明中被声明为“没有技术支持，并且是实验性质的”（Unsupported and Experimental）产品，日后可能会转正，也可能会在某个JDK版本中无声无息地消失。但事实上它们通常都非常稳定而且功能强大，也能在处理应用程序性能问题、定位故障时发挥很大的作用。

##### 4.2.1 jps：虚拟机进程状况工具

- JDK的很多小工具的名字都参考了UNIX命令的命名方式，jps（JVM Process Status Tool）是其中的典型。

- 除了名字像UNIX的ps命令之外，它的功能也和ps命令类似：可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。

  - 虽然功能比较单一，但它绝对是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。
  - 对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID，Process Identifier）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID
  - 但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就必须依赖 jps 命令显示主类的功能才能区分了。

- 选项

  - | 选项 | 作用                                                     |
    | ---- | -------------------------------------------------------- |
    | -q   | 只输出 LVMID，省略主类的名称                             |
    | -m   | 输出虚拟机进程启动时传递给主类 main() 函数的参数         |
    | -l   | 输出主类的全名，如果进程执行的是 JAR 包，则输出 JAR 路径 |
    | -v   | 输出虚拟机进程启动时的 JVM 参数                          |

##### 4.2.2 jstat：虚拟机统计信息监视工具

- jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。

- 它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据

  - 在没有 GUI 图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。

- jstat命令格式为：

  ```shell
  jstat [ option vmid [interval[s|ms] [count]] ]
  ```

  - 对于命令格式中的 VMID 与 LVMID 需要特别说明一下

    - 如果是本地虚拟机进程，VMID 与 LVMID 是一致的；

    - 如果是远程虚拟机进程，那 VMID 的格式应当是：

      ```
      [protocol:][//]lvmid[@hostname[:port]/servername]
      ```

  - 参数interval和count代表查询间隔和次数

    - 如果省略这2个参数，说明只查询一次。

    - 假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：

      ```shell
      jstat -gc 2764 250 20
      ```

  - 选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。

    - | 选项              | 作用                                                         |
      | ----------------- | ------------------------------------------------------------ |
      | -class            | 监视类加载、卸载数量、总空间以及类加载所耗费的时间           |
      | -gc               | 监视 Java 堆状况，包括 Eden 区、2 个 Survivor 区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息 |
      | -gccapacity       | 监视内容与 -gc 基本相同，但输出主要关注 Java 堆各大区域使用到的最大、最小空间 |
      | -gcutil           | 监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比 |
      | -gcgauge          | 与 -gcutil 功能一样，但是会额外输出导致上一次垃圾收集产生的原因 |
      | -gcnew            | 监视新生代垃圾收集状况                                       |
      | -gcnewcapacity    | 监视内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间 |
      | -gcold            | 监视老年代垃圾收集状况                                       |
      | -gcoldcapacity    | 监视内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间 |
      | -gcpermcapacity   | 输出永久代使用到的最大、最小空间                             |
      | -compiler         | 输出即时编译器编译过的方法、耗时等信息                       |
      | -printcompilation | 输出已经被即时编译的方法                                     |

##### 4.2.3 jinfo：Java 配置信息监视工具

- jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机各项参数。

  - 使用 jps 命令的 -v 参数可以查看虚拟机启动时显式指定的参数列表
  - 但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了
  - jinfo还可以使用 -sysprops 选项把虚拟机进程的System.getProperties()的内容打印出来。

- JDK 6之后，jinfo在Windows和Linux平台都有提供，并且加入了在运行期修改部分参数值的能力（可以使用-flag[+|-]name或者-flag name=value在运行期修改一部分运行期可写的虚拟机参数值）。

- jinfo命令格式：

  ```shell
  jinfo [ option ] pid
  ```

##### 4.2.4 jmap：Java 内存映像工具

- jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。

  - 如果不使用 jmap 命令，要想获取 Java 堆转储快照也还有一些比较“暴力”的手段：
    - 譬如在第2章中用过的 -XX:+HeapDumpOnOutOfMemoryError 参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件
    - 通过 -XX:+HeapDumpOnCtrlBreak 参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件
    - 又或者在Linux系统下通过 Kill -3 命令发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。

- jmap的作用并不仅仅是为了获取堆转储快照，它还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。

- jmap命令格式：

  ```shell
  jmap [ option ] vmid
  ```

  - option选项的合法值与具体含义

    - | 选项           | 作用                                                         |
      | -------------- | ------------------------------------------------------------ |
      | -dump          | 生成 Java 堆转储快照。格式为 `-dump:[live,]format=b,file=<filename>`，其中 live 子参数说明是否只 dump 出存活的对象 |
      | -finalizerinfo | 显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只在 Linux/Solaris 平台下有效 |
      | -heap          | 显示 Java 堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在 Linux/Solaris 平台下有效 |
      | -histo         | 显示堆中对象统计信息，包括类、实例数量、合计容量             |
      | -permstat      | 以 ClassLoader 为统计口径显示永久代内存状态。只在 Linux/Solaris 平台下有效 |
      | -F             | 当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生成 dump 快照。只在 Linux/Solaris 平台下有效 |

##### 4.2.5 jhat：虚拟机堆转储快照分析工具

- JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。
- jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。
- 在实际工作中，除非手上真的没有别的工具可用，否则多数人是不会直接使用jhat命令来分析堆转储快照文件的，主要原因有两个方面。
  - 一是一般不会在部署应用程序的服务器上直接分析堆转储快照，即使可以这样做，也会尽量将堆转储快照文件复制到其他机器上进行分析，因为分析工作是一个耗时而且极为耗费硬件资源的过程，既然都要在其他机器上进行，就没有必要再受命令行工具的限制了。
  - 另外一个原因是jhat的分析功能相对来说比较简陋，后文将会介绍到的VisualVM，以及专业用于分析堆转储快照文件的Eclipse Memory Analyzer、IBM HeapAnalyzer 等工具，都能实现比jhat更强大专业的分析功能。

##### 4.2.6 jstack：Java 堆栈跟踪工具

- jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。

  - 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。
  - 线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。

- jstack命令格式：

  ```shell
  jstack [ option ] vmid
  ```

  - option选项的合法值与具体含义

    - | 选项 | 作用                                          |
      | ---- | --------------------------------------------- |
      | -F   | 当正常输出的请求不被响应时，强制输出线程堆栈  |
      | -l   | 除堆栈外，显示关于锁的附加信息                |
      | -m   | 如果调用到本地方法的话，可以显示 C/C++ 的堆栈 |

- 从JDK 5起，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。

  - 使用这个方法可以通过简单的几行代码完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈，这也算是笔者的一个小经验。

##### 4.2.7 基础工具总结

- 基础工具：用于支持基本的程序创建和运行

  - | 名称         | 主要作用 |
    | ------------ | -------- |
    | appletviewer |          |
    | extcheck     |          |
    | jar          |          |
    | java         |          |
    | javac        |          |
    | javadoc      |          |
    | javah        |          |
    | javap        |          |
    | jlink        |          |
    | jdb          |          |
    | jdeps        |          |
    | jdeprscan    |          |

- 安全：用于程序签名、设置安全测试等

  - | 名称       | 主要作用 |
    | ---------- | -------- |
    | keytool    |          |
    | jarsigner  |          |
    | policytool |          |

- 国际化：用于创建本地语言文件

  - | 名称         | 主要作用 |
    | ------------ | -------- |
    | native2ascii |          |

- 远程方法调用：用于跨Web或网络的服务交互

  - | 名称        | 主要作用 |
    | ----------- | -------- |
    | rmic        |          |
    | rmiregistry |          |
    | rmid        |          |
    | serialver   |          |

- Java IDL与RMI-IIOP：在JDK 11中结束了十余年的CORBA支持，这些工具不再提供

  - | 名称       | 主要作用 |
    | ---------- | -------- |
    | tnameserv  |          |
    | idlj       |          |
    | orbd       |          |
    | servertool |          |

- 部署工具：用于程序打包、发布和部署

  - | 名称         | 主要作用 |
    | ------------ | -------- |
    | javapackager |          |
    | pack200      |          |
    | unpack200    |          |

- Java Web Start

  - | 名称   | 主要作用 |
    | ------ | -------- |
    | javaws |          |

- 性能监控和故障处理：用于监控分析Java虚拟机运行信息，排查问题

  - | 名称      | 主要作用 |
    | --------- | -------- |
    | jps       |          |
    | jstat     |          |
    | jstatd    |          |
    | jinfo     |          |
    | jmap      |          |
    | jhat      |          |
    | jstack    |          |
    | jhsdb     |          |
    | jsadebugd |          |
    | jcmd      |          |
    | jconsole  |          |
    | jmc       |          |
    | jvisualvm |          |

- WebService工具：与CORBA一起在JDK 11中被移除

  - | 名称      | 主要作用 |
    | --------- | -------- |
    | schemagen |          |
    | wsgen     |          |
    | wsimport  |          |
    | xjc       |          |

- REPL和脚本工具

  - | 名称       | 主要作用 |
    | ---------- | -------- |
    | jshell     |          |
    | jjs        |          |
    | jrunscript |          |

#### 4.3 可视化故障处理工具

- JDK中除了附带大量的命令行工具外，还提供了几个功能集成度更高的可视化工具，用户可以使用这些可视化工具以更加便捷的方式进行进程故障诊断和调试工作。
  - 这类工具主要包括JConsole、JHSDB、VisualVM和JMC四个。
    - 其中，JConsole是最古老，早在JDK 5时期就已经存在的虚拟机监控工具
    - 而JHSDB虽然名义上是JDK 9中才正式提供，但之前已经以sa-jdi.jar包里面的HSDB（可视化工具）和CLHSDB（命令行工具）的形式存在了很长一段时间。它们两个都是JDK的正式成员，随着JDK一同发布，无须独立下载，使用也是完全免费的。
    - VisualVM在JDK 6 Update 7中首次发布，直到JRockit Mission Control与OracleJDK的融合工作完成之前，它都曾是Oracle主力推动的多合一故障处理工具，现在它已经从OracleJDK中分离出来，成为一个独立发展的开源项目。VisualVM已不是JDK中的正式成员，但仍是可以免费下载、使用的。
    - Java Mission Control，曾经是大名鼎鼎的来自BEA公司的图形化诊断工具，随着BEA公司被Oracle收购，它便被融合进OracleJDK之中。在JDK 7 Update 40时开始随JDK一起发布，后来Java SEAdvanced产品线建立，Oracle明确区分了Oracle OpenJDK和OracleJDK的差别，JMC从JDK 11开始又被移除出JDK。
      - 虽然在2018年Oracle将JMC开源并交付给OpenJDK组织进行管理，但开源并不意味着免费使用，JMC需要与HotSpot内部的“飞行记录仪”（Java Flight Recorder，JFR）配合才能工作，而在JDK 11以前，JFR的开启必须解锁OracleJDK的商业特性支持（使用JCMD的 VM.unlock_commercial_features或启动时加入-XX:+UnlockCommercialFeatures参数），所以这项功能在生产环境中仍然是需要付费才能使用的商业特性。

##### 4.3.1 JHSDB：基于服务性代理的调试工具

##### 4.3.2 JConsole：Java 监视和管理控制台

##### 4.3.3 VisualVM：多合一故障处理工具

- VisualVM（All-in-One Java Troubleshooting Tool）是功能最强大的运行监视和故障处理程序之一，曾经在很长一段时间内是Oracle官方主力发展的虚拟机故障处理工具。
  - Oracle曾在VisualVM的软件说明中写上了“All-in-One”的字样，预示着它除了常规的运行监视、故障处理外，还将提供其他方面的能力，譬如性能分析（Profiling）。
  - 而且相比第三方工具，VisualVM还有一个很大的优点：不需要被监视的程序基于特殊Agent去运行，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。
- 首次启动VisualVM后，读者先不必着急找应用程序进行监测，初始状态下的VisualVM并没有加载任何插件，虽然基本的监视、线程面板的功能主程序都以默认插件的形式提供，但是如果不在VisualVM上装任何扩展插件，就相当于放弃它最精华的功能，和没有安装任何应用软件的操作系统差不多。
- 挑选几个有特色的功能和插件进行简要介绍
  - 生成、浏览堆转储快照
    - 在VisualVM中生成堆转储快照文件有两种方式，可以执行下列任一操作：
      - 在“应用程序”窗口中右键单击应用程序节点，然后选择“堆Dump”。
      - 在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视”标签中单击“堆Dump”。
    - 生成堆转储快照文件之后，应用程序页签会在该堆的应用程序下增加一个以[heap-dump]开头的子节点，并且在主页签中打开该转储快照
  - 分析程序性能
    - 在Profiler页签中，VisualVM提供了程序运行期间方法级的处理器执行时间分析以及内存分析。
    - 做Profiling分析肯定会对程序运行性能有比较大的影响，所以一般不在生产环境使用这项功能，或者改用JMC来完成，JMC的Profiling能力更强，对应用的影响非常轻微。
  - BTrace动态日志跟踪
    - BTrace 是一个很神奇的VisualVM插件，它本身也是一个可运行的独立程序。
    - BTrace的作用是在不中断目标程序运行的前提下，通过HotSpot虚拟机的Instrument功能动态加入原本并不存在的调试代码。
    - BTrace的用途很广泛，打印调用堆栈、参数、返回值只是它最基础的使用形式，在它的网站上有使用BTrace进行性能监视、定位连接泄漏、内存泄漏、解决多线程竞争问题等的使用案例，有兴趣的读者可以去网上了解相关信息。
    - BTrace能够实现动态修改程序行为，是因为它是基于Java虚拟机的Instrument开发的。
      - Instrument是Java虚拟机工具接口（Java Virtual Machine Tool Interface，JVMTI）的重要组件，提供了一套代理（Agent）机制，使得第三方工具程序可以以代理的方式访问和修改Java虚拟机内部的数据。阿里巴巴开源的诊断工具Arthas也通过Instrument实现了与BTrace类似的功能。

##### 4.3.4 Java Mission Control：可持续在线的监控工具

#### 4.4 HotSpot 虚拟机插件及工具

- HotSpot的研发过程中，开发团队曾经编写（或者收集）过不少虚拟机的插件和辅助工具，它们存放在HotSpot源码hotspot/src/share/tools目录下，包括（含曾经有过但新版本中已被移除的）：
  - Ideal Graph Visualizer：用于可视化展示C2即时编译器是如何将字节码转化为理想图，然后转化为机器码的。
  - Client Compiler Visualizer [1]：用于查看C1即时编译器生成高级中间表示（HIR），转换成低级中间表示（LIR）和做物理寄存器分配的过程。
  - MakeDeps：帮助处理HotSpot的编译依赖的工具。
  - Project Creator：帮忙生成Visual Studio的.project文件的工具。
  - LogCompilation：将-XX:+LogCompilation输出的日志整理成更容易阅读的格式的工具。
  - HSDIS：即时编译器的反汇编插件。
- 关于Client Compiler Visualizer 和 Ideal Graph Visualizer，在本书第11章会有专门的使用介绍
- 而 Project Creator、LogCompilation、MakeDeps 这三个工具对本书的讲解和实验帮助有限
- 最后一个 HSDIS 是学习、实践本书第四部分“程序编译与代码优化”的有力辅助工具，借本章讲解虚拟机工具的机会，简要介绍其使用方法。
  - HSDIS是一个被官方推荐的HotSpot虚拟机即时编译代码的反汇编插件，它包含在HotSpot虚拟机的源码当中
  - HSDIS插件的作用是让HotSpot的-XX：+PrintAssembly指令调用它来把即时编译器动态生成的本地代码还原为汇编代码输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。
  - JITWatch 是HSDIS经常搭配使用的可视化的编译日志分析工具

## 调优分析实战

### 具体问题

- 高并发后台怎么优化GC，我主要是说了调整eden和surival的比例啥啥啥的
- GC优化，程序中应该如何优化？
- 有没有做过 JVM 调优？
- jvm参数调优怎么做的
  我回答的是用的微服务部署，有的微服务访问很频繁的，就多给他设置一些内存，比如网关，一些不怎么用到的，可以设置稍微小一点。然后他说：你们这就是全凭感觉瞎设置呗
- jvm调优做过吗，有哪些参数可以调，具体怎么调
- JVM 调优过程？怎么发现 JVM 的问题的？怎么做预警处理？
- JMV 优化过程，效果。为什么要升级垃圾收集器？
- jvm调优
- 加分项，美团面试的时候一面和面试官讨论了调优的一些细节 --xmns啥的
- 如果一个系统要进行调优你会考虑哪些方面；答:jvm(非常详细的展开），如果有数据库查询可以用索引等等。。。
- 聊了这么久虚拟机，你调过优吗？怎么调的。。。一脸懵逼
- 有没有jvm调优经验（没有）
- GC 调优
- CPU 占用率达到 100% 可能由什么造成
- jvm怎么调优，什么看gc的日志之类的
- 项目中关于 FULL GC 调优的细节
- cpu标高100%什么原因？为什么会出现死循环？
- 场景题：cpu 打满且频繁 full GC，怎么解决？
- JVM 调优经验 说一下做了什么？
- JVM 的常用参数有哪些
- JVM 调优常用的手段是什么
- jvm 调优你如何做的？现象->排查过程->解决方式->不同解决方案的对比与选择
- 有 jvm 调优的经验吗？实际工作中遇到过内存相关的问题吗？用过哪些堆栈工具调试？

### 思考方向

#### 5.2 案例分析

##### 5.2.1 大内存硬件上的程序部署策略

- 案例

  - 一个15万PV/日左右的在线文档类型网站最近更换了硬件系统
    - 服务器的硬件为四路志强处理器、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。
    - 整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的文档网站使用。
  - 软件版本选用的是64位的JDK 5，管理员启用了一个虚拟机实例，使用-Xmx和-Xms参数将Java堆大小固定在12GB。
  - 使用一段时间后发现服务器的运行效果十分不理想，网站经常不定期出现长时间失去响应。

- 原因

  - 监控服务器运行状况后发现网站失去响应是由垃圾收集停顿所导致的

    - 在该系统软硬件条件下，HotSpot虚拟机是以服务端模式运行，默认使用的是吞吐量优先收集器，回收12GB的Java堆，一次FullGC的停顿时间就高达14秒。

  - 由于程序设计的原因，访问文档时会把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象大多在分配时就直接进入了老年代，没有在Minor GC中被清理掉。

  - 每一款Java虚拟机中的每一款垃圾收集器都有自己的应用目标与最适合的应用场景，如果在特定场景中选择了不恰当的配置和部署方式，自然会事倍功半。

    - 目前单体应用在较大内存的硬件上主要的部署方式有两种：
      - 通过一个单独的Java虚拟机实例来管理大量的Java堆内存
      - 同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源。

    - 此案例中的管理员采用了第一种部署方式。
      - 对于用户交互性强、对停顿时间敏感、内存又较大的系统，并不是一定要使用Shenandoah、ZGC这些明确以控制延迟为目标的垃圾收集器才能解决问题
      - 使用Parallel Scavenge/Old收集器，并且给Java虚拟机分配较大的堆内存也是有很多运行得很成功的案例的，但前提是必须把应用的Full GC频率控制得足够低，至少要低到不会在用户使用过程中发生，譬如十几个小时乃至一整天都不出现一次Full GC
        - 这样可以通过在深夜执行定时任务的方式触发Full GC甚至是自动重启应用服务器来保持内存可用空间在一个稳定的水平。
        - 控制Full GC频率的关键是老年代的相对稳定，这主要取决于应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。
      - 除此之外，如果读者计划使用单个Java虚拟机实例来管理大内存，还需要考虑下面可能面临的问题：
        - 回收大块堆内存而导致的长时间停顿，自从G1收集器的出现，增量回收得到比较好的应用，这个问题有所缓解，但要到ZGC和Shenandoah收集器成熟之后才得到相对彻底地解决。
        - 大内存必须有64位Java虚拟机的支持，但由于压缩指针、处理器缓存行容量（Cache Line）等因素，64位虚拟机的性能测试结果普遍略低于相同版本的32位虚拟机。
        - 必须保证应用程序足够稳定，因为这种大型单体应用要是发生了堆内存溢出，几乎无法产生堆转储快照（要产生十几GB乃至更大的快照文件），哪怕成功生成了快照也难以进行分析；如果确实出了问题要进行诊断，可能就必须应用JMC这种能够在生产环境中进行的运维工具。
        - 相同的程序在64位虚拟机中消耗的内存一般比32位虚拟机要大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的，可以开启（默认即开启）压缩指针功能来缓解。
    - 鉴于上述这些问题，现阶段仍然有一些系统管理员选择第二种方式来部署应用：同时使用若干个虚拟机建立逻辑集群来利用硬件资源。

##### 5.2.2 集群间同步导致的内存溢出

##### 5.2.3 堆外内存导致的溢出错误

##### 5.2.4 外部命令导致系统缓慢

##### 5.2.5 服务器虚拟机进程崩溃

##### 5.2.6 不恰当数据结构导致内存占用过大

##### 5.2.7 由 Windows 虚拟内存导致的长时间停顿

##### 5.2.8 由安全点导致长时间停顿

#### 5.3 实战：Eclipse 运行速度调优

##### 5.3.1 调优前的程序运行状态

##### 5.3.2 升级 JDK 版本的性能变化及兼容问题

##### 5.3.3 编译时间和类加载时间的优化

##### 5.3.4 调整内存设置控制垃圾收集频率

##### 5.3.5 选择收集器降低延迟

## 虚拟机执行子系统（Class 文件、字节码、类加载机制）

### 具体问题

- 类加载机制
- ClassLoader原理和应用
- Java中有个String类，如果我们自己写一个java.lang.String类，会出现问题吗 (参考《深入理解Java虚拟机》第7章 虚拟机类加载机制，主要讲了类加载器的种类和双亲委派模型)
- 类加载过程？类隔离了解过吗？
- 多态和重载的底层实现原理，字节码层面的了解过吗？
- Java的类加载过程、机制，每个过程的作用
- JAVA类加载过程（加载（类加载器问题） 验证 准备 解析 初始化）
- 类加载器
- 双亲委任
- 如果发生了冲突，会出现什么情况-- 编译不报错，运行调用bootstrapclassloader加载rt.jar中的类
- JVM 是怎么判断两个类相等
- 类加载器
- 类加载过程
- 双亲委派模型
- JVM 的类加载过程。谈到了双亲委派模型。
- 怎么打破双亲委派模型。自己实现一个类加载器，怎么打破类加载器？问具体的实现细节。
- 类加载器都有哪些 双亲委派机制
- 类加载过程？
- 类加载的过程是什么，每个过程具体做到了什么事
- 双亲委派模型的好处
- 双亲委派机制，和类加载器，双亲委派机制的源码看看？（问比较多次了）
- java 对象的内存结构？标记字是做什么的？
- 问 JVM：双亲委派模型的理解，有没有在项目中实践过自定义类加载器。
- 双亲委派模型的类加载机制？
- 同一个 JVM 能不能加载全县定性类名是相同的一个类？能不能加载同一个类？
- 简述双亲委派模型
- 简述类加载过程
- Java 的类加载过程；
- 介绍一下双亲委派机制；
- 为什么双亲委派机制能够避免类的重复加载呢？
- 如何自定义一个与 Java 核心方法同名同参数的函数呢？
- 双亲委派机制的双亲是那双亲呢？
- 自定义类加载的过程是什么？
- 类加载机制

### 思考方向

#### 6、类文件结构

- 6.2 无关性的基石
- 6.3 Class 类文件的结构
  - 6.3.1 魔数与 Class 文件的版本
  - 6.3.2 常量池
    - 常量池中主要存放两大类常量：
      - 字面量（Literal）
        - 字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。
      - 符号引用（Symbolic References）。
        - 而符号引用则属于编译原理方面的概念，主要包括下面几类常量：
          - 被模块导出或者开放的包（Package）
          - 类和接口的全限定名（Fully Qualified Name）
          - 字段的名称和描述符（Descriptor）
          - 方法的名称和描述符
          - 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
          - 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）
  - 6.3.3 访问标志
    - ACC_PUBLIC
    - ACC_FINAL
    - ACC_SUPER
    - ACC_INTERFACE
    - ACC_ABSTRACT
    - ACC_SYNTHETIC
    - ACC_ANNOTATION
    - ACC_ENUM
    - ACC_MODULE
  - 6.3.4 类索引、父类索引与接口索引集合
  - 6.3.5 字段表集合
  - 6.3.6 方法表集合
    - 方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项
      - 因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。
      - 与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。
  - 6.3.7 属性表集合
- 6.4 字节码指令简介
  - 6.4.1 字节码与数据类型
    - 对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。
    - 大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。
  - 6.4.2 加载和存储指令
    - 这类指令包括：
      - 将一个局部变量加载到操作栈：`iload`、`iload_<n>`、`lload`、`lload_<n>`、`fload`、`fload_<n>`、`dload`、`dload_<n>`、`aload`、`aload_<n>`
      - 将一个数值从操作数栈存储到局部变量表：`istore`、`istore_<n>`、`lstore`、`lstore_<n>`、`fstore`、`fstore_<n>`、`dstore`、`dstore_<n>`、`astore`、`astore_<n>`
      - 将一个常量加载到操作数栈：`bipush`、`sipush`、`ldc`、`ldc_w`、`ldc2_w`、`aconst_null`、`iconst_m1`、`iconst_<i>`、`lconst_<l>`、`fconst_<f>`、`dconst_<d>`
      - 扩充局部变量表的访问索引的指令：`wide`
    - 上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如 `iload_<n>`），这些指令助记符实际上代表了一组指令（例如 `iload_<n>`，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。
  - 6.4.3 运算指令
    - 所有的算术指令包括：
      - 加法指令：iadd、ladd、fadd、dadd
      - 减法指令：isub、lsub、fsub、dsub
      - 乘法指令：imul、lmul、fmul、dmul
      - 除法指令：idiv、ldiv、fdiv、ddiv
      - 求余指令：irem、lrem、frem、drem
      - 取反指令：ineg、lneg、fneg、dneg
      - 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
      - 按位或指令：ior、lor
      - 按位与指令：iand、land
      - 按位异或指令：ixor、lxor
      - 局部变量自增指令：iinc
      - 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp
  - 6.4.4 类型转换指令
    - Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（WideningNumeric Conversion，即小范围类型向大范围类型的安全转换）：
      - int类型到long、float或者double类型
      - long类型到float、double类型
      - float类型到double类型
    - 与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成
      - 这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。
  - 6.4.5 对象创建与访问指令
    - 这些指令包括：
      - 创建类实例的指令：new
      - 创建数组的指令：newarray、anewarray、multianewarray
      - 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic
      - 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload
      - 将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore
      - 取数组长度的指令：arraylength
      - 检查类实例类型的指令：instanceof、checkcast
  - 6.4.6 操作数栈管理指令
    - 包括：
      - 将操作数栈的栈顶一个或两个元素出栈：pop、pop2
      - 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2
      - 将栈最顶端的两个数值互换：swap
  - 6.4.7 控制转移指令
    - 控制转移指令包括：
      - 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne
      - 复合条件分支：tableswitch、lookupswitch
      - 无条件分支：goto、goto_w、jsr、jsr_w、ret
  - 6.4.8 方法调用和返回指令
    - 方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下五条指令用于方法调用：
      - invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。
      - invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
      - invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
      - invokestatic指令：用于调用类静态方法（static方法）。
      - invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。
    - 方法返回指令是根据返回值的类型区分的
      - 包括 ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。
  - 6.4.9 异常处理指令
    - 在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现
    - 除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。
    - 而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr 和 ret指令来实现，现在已经不用了），而是采用异常表来完成。
  - 6.4.10 同步指令
    - Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。
      - 方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。
      - 同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持
- 6.5 公有设计，私有实现
- 6.6 Class 文件结构的发展

#### 7、虚拟机类加载机制

- 7.1 概述
  - Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。
  - 与那些在编译时需要进行连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的
    - 这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销
    - 但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
      - 例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。
- 7.2 类加载的时机
  - 一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段
    - 其中验证、准备、解析三个部分统称为连接（Linking）
    - 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始
      - 请注意，这里笔者写的是按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。
    - 而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。
  - 关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握
  - 但是对于初始化阶段，《Java虚拟机规范》则是严格规定了**有且只有**六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：这六种场景中的行为称为**对一个类型进行主动引用**。
    - 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。
      - 能够生成这四条指令的典型Java代码场景有：
        - 使用new关键字实例化对象的时候。
        - 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
        - 调用一个类型的静态方法的时候。
    - 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
    - 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    - 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
    - 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
    - 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
- **7.3 类加载的过程**
  - 7.3.1 加载
    - 在加载阶段，Java虚拟机需要完成以下三件事情：
      - 通过一个类的全限定名来获取定义此类的二进制字节流。
        - 它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。许多举足轻重的Java技术都建立在这一基础之上，例如：
          - 从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
          - 从网络中获取，这种场景最典型的应用就是Web Applet。
          - 运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。
          - 由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。
          - 从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。
          - 可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。
      - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
      - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
    - 相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。
      - 加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。
    - 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载
      - 一个数组类（下面简称为C）创建过程遵循以下规则：
        - 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上（这点很重要，在7.4节会介绍，一个类型必须与类加载器一起确定唯一性）。
        - 如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。
        - 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。
      - 加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义
    - 加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。
  - 7.3.2 验证
    - 验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。
    - 验证阶段大致上会完成下面四个阶段的检验动作
      - 文件格式验证
        - 第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
        - 这一阶段可能包括下面这些验证点：
          - 是否以魔数0xCAFEBABE开头。
          - 主、次版本号是否在当前Java虚拟机接受范围之内。
          - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
          - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
          - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。
          - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
          - ……
        - 该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。
        - 这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储
          - 所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。
      - 元数据验证
        - 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求
        - 这个阶段可能包括的验证点如下：
          - 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
          - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
          - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
          - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。
          - ……
        - 第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。
      - 字节码验证
        - 第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
        - 这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：
          - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。
          - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
          - 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。
          - ……
        - 由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行。
          - 具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。
          - 这样就将字节码验证的类型推导转变为类型检查，从而节省了大量校验时间。
          - 而到了 JDK 7 之后，尽管虚拟机中仍然保留着类型推导验证器的代码，但是对于主版本号大于50（对应JDK6）的Class文件，使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到原来的类型推导的校验方式。
      - 符号引用验证
        - 最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。
        - 符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。
        - 本阶段通常需要校验下列内容：
          - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
          - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
          - 符号引用中的类、字段、方法的可访问性（private、protected、public、`<package>`）是否可被当前类访问。
        - 符号引用验证的主要目的是确保解析行为能正常执行
          - 如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。
    - 验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。
      - 如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
  - 7.3.3 准备
    - 准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段
      - 从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域
        - 在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；
        - 而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了
    - 关于准备阶段，还有两个容易产生混淆的概念笔者需要着重强调
      - 首先是这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中
      - 其次是这里所说的初始值“通常情况”下是数据类型的零值
        - “特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值
  - 7.3.4 解析
    - 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程
      - 符号引用在第6章讲解 Class 文件格式的时候已经出现过多次，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现
      - 那解析阶段中所说的直接引用与符号引用又有什么关联呢？
        - 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
        - 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
  - 7.3.5 初始化
- 7.4 类加载器
  - 7.4.1 类与类加载器
  - **7.4.2 双亲委派模型**
  - 7.4.3 破坏双亲委派模型
- 7.5 Java 模块化系统
  - 7.5.1 模块的兼容性
  - 7.5.2 模块化下的类加载器

#### 8、虚拟机字节码执行引擎

- **8.2 运行时栈帧结构**
  - 8.2.1 局部变量表
  - 8.2.2 操作数栈
  - 8.2.3 动态连接
  - 8.2.4 方法返回地址
  - 8.2.5 附加信息
- 8.3 方法调用
  - 8.3.1 解析
  - 8.3.2 分派
- **8.4 动态类型语言支持**
  - 8.4.1 动态类型语言
  - 8.4.2 Java 与动态类型
  - 8.4.3 java.lang.invoker 包
  - 8.4.4 invokedynamic 指令
  - 8.4.5 实战：掌控方法分派规则
- 8.5 基于栈的字节码解释执行引擎
  - 8.5.1 解释执行
  - 8.5.2 基于栈的指令集与基于寄存器的指令集
  - 8.5.3 基于栈的解释器执行过程

#### 9、类加载及其执行子系统的案例与实战

- 9.2 案例分析
  - 9.2.1 Tomcat：正统的类加载器架构
  - **9.2.2 OSGi：灵活的类加载器架构**
  - 9.2.3 字节码生成技术与动态代理的实现
  - 9.2.4 Backport 工具：Java 的时光机器
- 9.3 实战：自己动手实现远程执行功能

## 程序编译与代码优化

### 具体问题

- **JVM Server模式与client模式启动的差别？**
- **Java 语法糖（lambda、自动装箱、for-each、泛型）**
- 动态编译和静态编译的区别
- 为何引入 JIT 编译？逃逸分析是什么？
- 什么是逃逸，是不是所有对象都在堆上分配内存

### 思考方向



## 内存模型与线程

### 具体问题

- Java 内存模型
- Java内存模型
- jvm内存模型jmm 知道的全讲讲
- jvm内存模型
- jvm内存模型
- JVM内存模型
- jvm的内存模型
- 讲一讲java的内存模型
- JAVA内存区域（堆 栈等） JAVA内存模型（工作内存 主内存等）
- jvm内存模型，如何分配内存
- 写屏障和读屏障的区别是什么？
- mesi协议（缓存一致性协议）
- 内存屏障
- Java内存模型说一下
- JVM的内存模型 （我开始以为他问的是工作内存和主内存），他说不是，不用讲这些，他说记住我问的问题，我说您问的是栈，堆之类吗？他说是的，然后就给他解释（我一直记得内存结构是这些，内存模型是工作内存和主内存，还特意区分了）  
- volatile 的作用是什么
  - 防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性
  - 会主动刷新存储

- JVM 内存模型和垃圾回收；
- 讲一下  JMM
- 讲解一下 JVM 内存模型；
- 讲解一下 JVM 的内存模型；
- 讲讲 JMM
- JVM 的内存模型？运行时是怎么运作的？

### 思考方向

## 线程安全与锁优化

### 具体问题

- 字节码头部有哪些组成？说说锁标记和锁升级
- 偏向锁、轻量级锁是怎么做到的，我回答的是每个对象都有对象头，对象头里做的标记，然后他问我对象头里有哪些信息

### 思考方向