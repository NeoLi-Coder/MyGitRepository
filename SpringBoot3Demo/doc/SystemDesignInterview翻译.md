# 前言

我们很高兴您决定加入我们学习系统设计面试。系统设计面试问题是所有技术问题中最难解决的面试。这些问题要求受访者设计软件的体系结构系统，可以是新闻源、谷歌搜索、聊天系统等。这些问题是令人生畏，而且没有特定的模式可循。问题通常很大范围广泛且模糊。流程是开放式的，不明确，没有标准或正确
答复。
公司广泛采用系统设计面试，因为在这些面试中测试的沟通和解决问题的技能与软件工程师的日常工作要求相似。根据受访者如何分析一个模糊的问题以及她如何一步一步地解决这个问题。测试的能力还包括她如何解释想法，与他人讨论，并对系统进行评估和优化。在英语中，使用“she”比“他或她”或在两者之间跳跃更流畅。为了使阅读更容易，我们使用贯穿本书的女性代词。并非有意不尊重男性工程师。

系统设计问题是开放式的。就像在现实世界中一样，有很多系统中的差异和变化。期望的结果是提出一个架构以实现系统设计目标。讨论可能会以不同的方式进行
取决于面试官。一些面试官可能会选择高级架构进行面试各方面；而有些人可能会选择一个或多个领域来关注。通常应充分理解需求、限制和瓶颈，以确定
面试官和被面试者。

本书的目的是提供一种可靠的策略来进行系统设计问题。正确的策略和知识对面试的成功至关重要。

这本书提供了构建可扩展系统的坚实知识。知识越多从阅读这本书中获得的经验，你在解决系统设计方面的问题时就越有能力。

本书还提供了一个关于如何解决系统设计问题的循序渐进的框架。它提供了许多例子来说明系统化的方法，并提供了详细的步骤可以跟随。通过不断的练习，您将具备应对系统设计的能力面试问题。

# 第 1 节：从零到百万用户规模

设计一个支持数百万用户的系统是一项挑战，这是一个需要不断改进和无尽改进的旅程。在本章中，我们构建了一个支持单个用户的系统，并逐步扩大其服务于数百万用户。在阅读完本章之后，您将掌握一些技巧，这将帮助您破解系统设计的面试问题。

## 单服务器设置

千里之行始于足下，建立一个复杂的系统也不例外。从一些简单的事情开始，一切都运行在一台服务器上。图 1-1 显示了一个单个服务器设置的说明，其中所有内容都运行在一台服务器上： web 应用程序、数据库、缓存等。

要理解此设置，调查请求流和流量源会很有帮助。让我们先看一下请求流（图 1-2)

1. 用户可以通过 api.mysite.com 等域名来访问网站。通常，域名系统（DNS）是由第三方提供的付费服务，而不是由我们的服务器托管的。
2. 互联网协议（IP）地址被返回到浏览器或移动应用程序。在该示例中，将返回 IP 地址 15.125.23.214。 
3. 一旦获得了 IP 地址，超文本传输协议（HTTP）[1] 请求将直接发送到您的 web服务器。
4. web 服务器返回 HTML 页面或 JSON 响应以进行呈现。

接下来，让我们检查一下流量源。到 web 服务器的流量来自两个来源： web 应用程序和移动应用程序。

- Web 应用程序：它使用服务器端语言（Java、Python 等）的组合。来处理业务逻辑、存储等，以及用来进行演示的客户端语言（HTML 和 JavaScript）。

- 移动应用： HTTP 协议是移动应用与 web 服务器之间的通信协议。JavaScript 对象表示法（JSON）由于其简单性，是通常用于传输数据的 API 响应格式。一个 JSON 格式的 API 响应示例如下所示：

  ```json
  // GET /users/12 – Retrieve user object for id = 12
  {
      "id": 12,
      "firstName": "John",
      "lastName": "Smith",
      "address": {
          "streetAddress": "21 2nd Street",
          "city": "New York",
          "state": "NY",
          "postalCode": 10021
      },
      "phoneNumbers": [
          "212 555-1234",
          "646 555-4567"
      ]
  }
  ```

## 数据库

随着用户基础的增长，一个服务器是不够的，我们需要多个服务器：一个用于 web /移动流量，另一个用于数据库（图 1-3）。分离 Web /移动流量(web 层）和数据库（数据层）服务器可以独立扩展。

## 使用哪个数据库？

您可以在传统的关系数据库和非关系数据库之间进行选择。让我们来看看他们之间的差异。

关系数据库也被称为关系数据库管理系统（RDBMS）或 SQL 数据库。最流行的版本是 MySQL、Oracle 数据库、PostgreSQL 等。关系数据库在表和行中表示和存储数据。您可以使用跨不同数据库表的 SQL 来执行连接操作。

非关系数据库也被称为 NoSQL 数据库。最受欢迎的产品有 CouchDB、Neo4j、Cassandra、HBase、亚马逊 DynamoDB 等。[2].这些数据库被分为四类：键值存储、图存储、列存储和文档存储。在非关系型数据库中，通常不支持连接（join）操作。

对于大多数开发人员来说，关系数据库是最好的选择，因为它们已经存在了 40 多年，而且从历史上看，它们工作得很好。但是，如果关系数据库不适合特定的用例，那么在关系数据库之外进行探索是非常重要的。非关系数据库可能是正确的选择，如果：

- 您的应用程序需要超低的延迟。
- 您的数据是非结构化的，或者您没有任何关系数据。
- 您只需要序列化和反序列化数据（JSON、XML、YAML等）。
- 您需要存储大量的数据。

## 垂直缩放 vs 水平缩放

垂直缩放（vertical scaling），被称为“scale up”，是指给您的服务器增加更多性能的过程（CPU、RAM 等）。水平缩放称为“scale-out”，允许您通过在资源池中添加更多服务器来扩展。

当流量较低时，垂直缩放是一个很好的选择，而垂直缩放的简单性是其主要优势。不幸的是，它带有严重的局限性。

- 垂直缩放有一个很硬的限制。不可能为一台服务器添加无限的CPU和内存。
- 垂直缩放没有故障转移和冗余性。如果一个服务器宕机，网站/应用程序就会完全宕机。

由于垂直缩放的限制，水平缩放更适合用于大规模应用。

在之前的设计中，用户可以直接连接到 web 服务器。如果 web 服务器处于脱机状态，则用户将无法访问该网站。在另一种情况下，如果许多用户同时访问 web 服务器，并且它达到了 web 服务器的负载限制，那么用户通常会经历较慢的响应或无法连接到服务器。负载平衡器是解决这些问题的最佳技术。

## 负载均衡器

负载均衡器在负载均衡集中定义的 web 服务器之间均匀地分配传入的流量。图 1-4 显示了负载平衡器的工作原理。

如图 1-4 所示，用户直接连接到负载均衡器的公共 IP。有了这个设置，客户端就再也无法直接访问 web 服务器了。为了获得更好的安全性，私有 IP 用于服务器之间的通信。私有 IP 是指只能在同一网络中的服务器之间可访问的 IP 地址；然而，它在互联网上是无法访问的。负载均衡器通过私有 IP 与 web 服务器进行通信。

在图 1-4 中，在添加了一个负载平衡器和第二个 web 服务器后，我们成功地解决了没有发生故障转移的问题，并提高了 web 层的可用性。详细说明如下：

- 如果服务器 1 脱机，那么所有的流量都将被路由到服务器 2。这可以防止网站脱机。我们还将向服务器池中添加一个新的健康的 web 服务器，以平衡负载。
- 如果网站流量的增长迅速，并且两个服务器不足以处理流量，则负载均衡器可以优雅地处理这个问题。您只需要向 web 服务器池中添加更多的服务器，并且负载平衡器就会自动开始向它们发送请求。

现在 web 层看起来不错，那么数据层呢？当前的设计有一个数据库，因此它不支持故障转移和冗余。数据库复制是解决这些问题的一种常用技术。让我们来看看吧。

## 数据库复制

引用维基百科：“数据库复制可以用于许多数据库管理系统，通常在原始（主）和副本（从）之间的主/从关系”[3]。

主数据库通常只支持写操作。从属数据库从主数据库获取数据的副本，并且只支持读取操作。所有数据修改命令都必须发送到主数据库。大多数应用程序需要更高的读写比；因此，系统中从数据库的数量通常大于主数据库的数量。图 1-5 显示了一个具有多个从属数据库的主数据库。

数据库复制的优点：

- 更好的性能：在主从模型中，所有的写入和更新都发生在主节点中；然而，读取操作分布在各个从节点之间。这个模型提高了性能，因为它允许并行处理更多的查询。
- 可靠性：如果您的一个数据库服务器被自然灾害破坏，如台风或地震，数据仍然被保存。您不需要担心数据丢失，因为数据是跨多个位置复制的。
- 高可用性：通过在不同的位置复制数据，即使数据库脱机，您的网站仍然可以运行，因为您可以访问存储在另一个数据库服务器中的数据。

在上一节中，我们将讨论负载平衡器如何帮助提高系统的可用性。我们在这里问同样的问题：如果其中一个数据库脱机了怎么办？图 1-5 中讨论的架构设计可以处理以下情况：

- 如果只有一个从数据库可用，并且它脱机，则读取操作将暂时引导到主数据库。一旦发现问题，新的从数据库将取代旧数据库。如果有多个从数据库可用，则读取操作重定向到其他健康从数据库。一个新的数据库服务器将取代旧的数据库服务器。
- 如果主数据库脱机，一个从数据库将被提升为新的主数据库。所有的数据库操作都将在新的主数据库上临时执行。一个新的从数据库将立即取代旧的从数据库以进行数据复制。在生产系统中，升级新的主数据更为复杂，因为从数据库中的数据可能不是最新的。丢失的数据需要通过运行数据恢复脚本来进行更新。虽然其他一些复制方法，如多主复制和循环复制可以提供帮助，但这些设置更为复杂；他们的讨论超出了这本书的范围。有兴趣的读者应参考所列出的参考资料[4] [5]。

图 1-6 显示了添加负载平衡器和数据库复制后的系统设计。

让我们来看一下设计：

- 用户从 DNS 获得负载均衡器的 IP 地址。
- 一个用户将负载均衡器与此 IP 地址连接起来。
- HTTP 请求被路由到服务器 1 或服务器 2。
- web 服务器从从属数据库中读取用户数据。
- web 服务器会将任何数据修改操作路由到主数据库。这包括写入、更新和删除操作。

现在，您对 web 和数据层有了深入的了解，是时候提高加载/响应时间了。这可以通过添加一个缓存层，并将静态内容（JavaScript/CSS/图像/视频文件）转移到内容传递网络（CDN）来实现。

## 缓存

缓存是一个临时存储区域，它将昂贵的响应或频繁访问的数据的结果存储在内存中，以便更快地提供后续的请求。如图 1-6 所示，每次加载一个新的网页时，都会执行一个或多个数据库调用来获取数据。反复调用数据库对应用程序性能的影响很大。高速缓存可以缓解这个问题。

## 缓存层

缓存层是一个临时的数据存储层，比数据库要快得多。拥有一个单独的缓存层的好处包括更好的系统性能、减少数据库工作负载的能力，以及独立扩展缓存层的能力。图 1-7 显示了一个高速缓存服务器的可能设置：

在收到一个请求后，web 服务器首先检查该缓存是否有可用的响应。如果有，它会将数据发送回客户端。如果没有，它将查询数据库，将响应存储在缓存中，并将其发送回客户端。这种缓存策略称为通读缓存。根据数据类型、大小和访问模式，还可以使用其他缓存策略。之前的一项研究解释了不同的缓存策略是如何工作的[6]。

与缓存服务器的交互很简单，因为大多数缓存服务器都为通用编程语言提供 api。下面的代码片段显示了典型的 mem 缓存 api：

```python
SECONDS = 1
cache.set('myKey', 'hi there', 3600 * SECONDS)
cache.get('myKey')
```

## 考虑使用缓存

以下是在使用高速缓存系统时需要考虑的一些注意事项：

- 决定何时使用高速缓存。当数据经常读取但很少修改时，请考虑使用缓存。由于缓存的数据存储在易失性内存中，因此缓存服务器不适合持久化数据。例如，如果高速缓存服务器重新启动，则内存中的所有数据都将丢失。因此，重要的数据应该保存在持久的数据存储中。
- 过期政策。实施过期策略是一个很好的做法。缓存数据过期，将从缓存中删除。当没有过期策略时，缓存的数据将永久存储在内存中。建议不要使过期日期太短，因为这将导致系统太频繁地从数据库中重新加载数据。同时，建议不要配置过期时间太长，以免数据可能过时。
- 一致性：这涉及到保持数据存储和高速缓存的同步状态。由于数据存储和缓存上的数据修改操作不在单个事务中，因此可能会发生不一致。当跨多个区域进行缩放时，保持数据存储和缓存之间的一致性具有挑战性。有关更多细节，请参考脸书发布的题为“扩展脸书内存缓存”的论文[7]。
- 减轻故障：单个缓存服务器代表一个潜在的单点故障（SPOF），在维基百科中定义如下：“单点故障（SPOF）是系统的一部分，如果它失败，将停止整个系统工作”[8]。因此，建议跨不同的数据中心使用多个高速缓存服务器，以避免使用SPOF。另一种推荐的方法是按一定的百分比过剩供应所需的内存。随着内存使用量的增加，这就提供了一个缓冲区。
- 驱逐策略：一旦缓存已满，任何将项目添加到缓存中的请求都可能导致现有项目被删除。这被称为高速缓存驱逐。最近最少使用的（LRU）是最流行的高速缓存驱逐策略。其他驱逐策略，如最少常用（LFU）或第一出（FIFO），可以用来满足不同的用例。

## 内容分发网络（CDN）

CDN 是一个由地理上分散的服务器组成的网络，用于交付静态内容。CDN 服务器可以缓存静态内容，如图像、视频、CSS、JavaScript 文件等。

动态内容缓存是一个相对较新的概念，并且超出了这本书的范围。它支持缓存基于请求路径、查询字符串、Cookie 和请求头的 HTML 页面。有关此信息，请参考参考材料[9]中提到的文章。这本书重点介绍了如何使用 CDN 来缓存静态内容。

以下是 CDN 在高级级别上的工作方式：当用户访问一个网站时，最接近该用户的 CDN 服务器将提供静态内容。直观地说，来自 CDN 服务器的用户越多，网站加载就越慢。例如，如果 CDN 服务器在旧金山，洛杉矶的用户将比欧洲的用户更快地获得内容。图 1-9 是一个很好的示例，它显示了 CDN 如何改进加载时间。

图 1-10 演示了 CDN 的工作流。

1. 用户 A 尝试通过使用图像 URL 来获取 image.png。该 URL 的域名由 CDN 提供程序提供。以下两个图像 URL 是用于演示亚马逊和 Akamaicdn 上的图像 URL 的外观的示例：
   - https://mysite.cloudfront.net/logo.jpg
   - https://mysite.akamai.com/image-manager/img/logo.jpg
2. 如果 CDN 服务器缓存中没有 image.png，CDN 服务器将从源请求文件，源可以是 web 服务器，也可以是像 Amazon S3 这样的在线存储。
3. 源将 image.png 返回到 CDN 服务器，其中包括可选的 HTTP 头实时时间（TTL），它描述了映像缓存的时间。
4. CDN 缓存图像并将其返回给用户 A。图像一直缓存在 CDN 中，直到 TTL 过期。 
5. 用户 B 发送一个获取相同图像的请求。 
6. 只要 TTL 没有过期，图像就会从缓存中返回。

## 使用 CDN 的考虑事项

- 成本：CDN 由第三方提供商运行，您需要收取进出 CDN 的数据传输费用。缓存不常用的资产不会提供显著的好处，因此您应该考虑将它们移出 CDN。
- 设置适当的缓存过期时间：对于对时间敏感的内容，设置缓存过期时间非常重要。缓存过期时间既不应太长也不应太短。如果它太长，内容可能就不再新鲜了。如果太短，可能会导致内容从原始服务器重新加载到 CDN。
- CDN 回退：你应该考虑你的网站/应用程序如何处理 CDN 失败。如果存在临时的 CDN 中断，客户端应该能够检测到问题并从源请求资源。
- 无效文件：您可以通过执行以下操作之一，在 CDN 文件过期之前从其删除文件：
  - 使用 CDN 供应商提供的 API 使 CDN 对象无效。
  - 使用对象版本控制来服务于对象的不同版本。要版本一个对象，您可以向 URL 添加一个参数，例如版本号。例如，版本号 2 被添加到查询字符串中：image.png?v=2。

图 1-11 显示了添加了 CDN 和高速缓存后的设计。

1. 静态资产（JS、CSS、图像等）不再由 web 服务器提供服务。它们从 CDN 中获取，以获得更好的性能。
2. 通过缓存数据，可以减轻数据库的负载。

## 无状态 Web 层

现在是时候考虑水平缩放 web 层了。为此，我们需要将状态（例如用户会话数据）从 web 层中移动出来。一个好的做法是将会话数据存储在持久存储中，如关系数据库或 NoSQL。集群中的每个 web 服务器都可以从数据库中访问状态数据。这被称为无状态的 web 层。

## 状态体系结构

有状态服务器和无状态服务器有一些关键的区别。有状态服务器从一个请求到下一个请求都会记住客户端数据（状态）。无状态服务器不保存任何状态信息。

图 1-12 显示了一个有状态的体系结构的示例。

在图 1-12 中，用户 A 的会话数据和配置文件图像存储在服务器 1 中。要对用户 A 进行认证，必须将 HTTP 请求路由到服务器 1。如果将请求发送到服务器 2 等其他服务器，则身份验证将失败，因为服务器 2 不包含用户 A 的会话数据。类似地，来自用户 B 的所有 HTTP 请求都必须路由到服务器 2；来自用户 C 的所有请求都必须发送到服务器 3。

问题是来自同一客户端的每个请求必须路由到相同的服务器。这可以在大多数负载平衡器中的粘性会话来完成[10]；然而，这增加了开销。使用这种方法，添加或删除服务器要困难得多。处理服务器故障也是一个挑战。

## 无状态体系结构

图 1-13 显示了一种无状态的体系结构。

在这种无状态体系结构中，来自用户的 HTTP 请求可以发送到任何 web 服务器，这些服务器从共享数据存储中获取状态数据。状态数据存储在一个共享的数据存储器中，并远离 web 服务器。无状态系统更简单、更健壮和可伸缩。

图 1-14 显示了使用无状态 web 层的更新设计。

在图 1-14 中，我们将会话数据从 web 层中移出，并将它们存储在持久性数据存储区中。共享的数据存储可以是一个关系数据库、内存缓存/Redis、NoSQL 等。选择 NoSQL 数据存储是因为它易于缩放。自动缩放是指根据流量负载自动添加或删除 web 服务器。在从 web 服务器中删除状态数据后，通过根据流量负载添加或删除服务器，可以很容易地实现 web 层的自动缩放。

你的网站发展迅速，并吸引了大量的国际用户。为了提高可用性并在更广泛的地理区域内提供更好的用户体验，支持多个数据中心至关重要。

## 数据中心

图 1-15 显示了一个具有两个数据中心的示例设置。在正常运行中，用户被 geoDNS 路由，也称为地理路由，到最近的数据中心，美国东部的分割流量为 x%，美国西部为（100-x）%。geoDNS 是一种 DNS 服务，它允许根据用户的位置将域名解析为 IP 地址。

在发生任何重大的数据中心中断时，我们将所有流量引导到一个健康的数据中心。在图 1-16 中，数据中心 2（US-West）脱机，100% 的流量被传输至数据中心 1（US-East）。

要实现多数据中心的设置，必须解决几个技术挑战：

- 流量重定向：需要有效的工具来将流量引导到正确的数据中心。GeoDNS 可以根据用户所在的位置将流量引导到最近的数据中心。
- 数据同步：来自不同地区的用户可以使用不同的本地数据库或缓存。在故障转移的情况下，流量可能会被路由到数据不可用的数据中心。一种常见的策略是跨多个数据中心复制数据。之前的一项研究显示了 Netflix 如何实现异步多数据中心复制[11]。
- 测试和部署：通过多数据中心的设置，在不同的地点测试您的网站/应用程序是很重要的。自动化部署工具对于保持所有数据中心的服务一致性至关重要[11]。

为了进一步扩展我们的系统，我们需要解耦系统的不同组件，以便它们可以独立地缩放。消息传递队列是许多现实世界的分布式系统用来解决这一问题的关键策略。

## 消息队列

消息队列是存储在内存中的持久组件，它支持异步通信。它作为一个缓冲区，并分发异步请求。消息队列的基本架构很简单。输入服务，称为生产者/发布者，它创建消息，并将它们发布到消息队列中。其他服务或服务器，称为消费者/订阅者，连接到队列，并执行由消息定义的操作。该模型如图 1-17 所示。

解耦使消息队列成为构建可伸缩和可靠的应用程序的首选体系结构。使用消息队列，当使用者无法处理该队列时，生产者可以将消息发布到该队列。即使生产者不可用，消费者也可以从队列中读取消息。

考虑以下用例：您的应用程序支持照片定制，包括裁剪、锐化、模糊等。这些定制任务需要一段时间来完成。在图 1-18 中，web 服务器会将照片处理作业发布到消息队列中。照片处理工作者从消息队列中获取作业，并异步地执行照片定制任务。生产者和消费者可以独立地进行缩放。当队列的大小变大时，会添加更多的工作者，以减少处理时间。但是，如果队列大部分时间都是空的，则可以减少工作者的数量。

## 日志记录、度量、自动化

当使用运行在一些服务器上的小网站时，日志记录、指标和自动化支持是很好的实践，但不是必要的。然而，现在你的网站已经发展为服务于一个大型企业，投资于这些工具是至关重要的。

日志记录：监视错误日志很重要，因为它有助于识别系统中的错误和问题。您可以在每个服务器级别的错误日志，或者使用工具将它们聚合到集中服务，以便于搜索和查看。

指标：收集不同类型的指标有助于帮助我们获得业务见解，并了解系统的健康状况。以下一些指标是有用的：

- 主机级指标：CPU、内存、磁盘I/O等。
- 聚合级别指标：例如，整个数据库层、高速缓存层等的性能。
- 关键业务指标：每日活跃用户、留存率、收入等。

自动化：当一个系统变得大而复杂时，我们需要构建或利用自动化工具来提高生产率。持续集成是一种很好的实践，其中每个代码签入都通过自动化进行验证，允许团队及早发现问题。此外，自动化您的构建、测试、部署过程等等。可以显著提高开发人员的生产力。

## 添加消息队列和不同的工具

图 1-19 显示了更新后的设计。由于空间的限制，图中只显示了一个数据中心。

1. 该设计包括一个消息队列，这有助于使系统更松散地耦合和故障弹性。 
2. 其中包括日志记录、监控、度量标准和自动化工具

随着数据的不断增长，数据库就会越来越超载。是时候缩放数据层了。

## 数据库缩放

数据库缩放有两种主要的方法：垂直缩放和水平缩放。

## 垂直缩放

垂直缩放，也被称为向上缩放，是通过增加更多的功率（CPU、RAM、磁盘等）来进行的缩放。到一个现有的机器。这里有一些功能强大的数据库服务器。根据 Amazon 关系数据库服务（RDS）[12]，您可以获得一个具有 24 TB 内存的数据库服务器。这种功能强大的数据库服务器可以存储和处理大量的数据。例如，stackoverflow.com 在 2013 年每月有超过 1000 万的独立访问者，但它只有一个主数据库[13]。然而，垂直缩放也带有一些严重的缺点：

- 你可以添加更多的 CPU、RAM 等。到您的数据库服务器，但有硬件限制。如果您有一个很大的用户基础，那么单台服务器是不够的。
- 单点故障的风险更大。
- 垂直缩放的总成本较高。功能强大的服务器要贵得多。

## 水平缩放

水平缩放，也称为分片，是添加更多服务器的做法。图 1- 20 将垂直缩放和水平缩放进行了比较。

分片将大型数据库分离成更小、更容易管理的部分，称为片（shards）。每个片共享相同的模式（schema），尽管每个片上的实际数据对片是唯一的。

图 1-21 显示了一个分片数据库的示例。用户数据根据用户 id 分配给数据库服务器。每当访问数据时，将使用哈希函数来查找相应的碎片。在我们的示例中，user_id % 4 被用作哈希函数。如果结果等于 0，则片 0 用于存储和获取数据。如果结果等于1，则使用片1。同样的逻辑也适用于其他的片。

图 1-22 显示了分形数据库中的用户表。

在实施分片策略时，需要考虑的最重要的因素是分片键的选择。分片键（称为分区键）由一个或多个决定数据如何分布的列组成。如图 1-22 所示，“user_id”是分片键。分片键允许您通过将数据库查询路由到正确的数据库来有效地检索和修改数据。在选择分片键时，最重要的标准之一是选择一个可以均匀分布数据的键。

分片是一种扩展数据库的伟大技术，但它远不是一个完美的解决方案。它给这个系统带来了复杂性和新的挑战：

**重分片数据**：当 1) 由于快速增长，一个单一的片不能再保存更多的数据时，就需要重分片数据。2) 由于数据分布不均匀，某些片可能会比其他片更快地经历片耗尽（shard exhaustion）。当片耗尽发生时，它需要更新分片函数和移动数据。一致性散列是解决这个问题的一种常用技术，这将在第 5 章中讨论。

**名人问题**：这也被称为热点键问题。对特定片的过度访问可能会导致服务器过载。想象一下，凯蒂·佩里、贾斯汀·比伯和 Lady Gaga 的数据都在同一个片。对于社交应用程序来说，这些片将被阅读操作所淹没。为了解决这个问题，我们可能需要为每个名人分配一块片。每个片甚至可能需要进一步的分割。

**连接和去规范化**：一旦一个数据库已经跨多个服务器进行了共享，就很难跨数据库片执行连接操作。一个常见的解决方法是将数据库去规格化，以便可以在单个表中执行查询。

在图 1-23 中，我们分割了数据库，以支持快速增长的数据流量。同时，一些非关系功能被移到 NoSQL 数据存储中，以减少数据库负载。这里有一篇介绍了许多 NoSQL [14] 用例的文章。

## 数百万用户及以上的用户

缩放一个系统是一个迭代的过程。重复我们在这一章中学到的东西可以让我们走得更远。需要更多的微调和新的策略来扩展超过数百万用户。例如，您可能需要优化系统，并将系统解耦到更小的服务。本章中所学到的所有技术都应该为应对新的挑战提供一个良好的基础。在这一章中，我们总结了我们如何扩展系统以支持数百万用户：

- 保持web层无状态
- 在每个层构建冗余
- 尽可能缓存数据
- 支持多个数据中心
- 将静态资产放在CDN主机
- 通过分片进行数据层缩放
- 分割各个层到单独的服务
- 监控您的系统和使用自动化工具

祝贺你能走到这一步！现在拍拍自己的背。干得好！

# 第 2 节：粗略估计

在系统设计面试中，有时会要求您使用粗略估计（back-of-the-envelope estimation）来估计系统容量或性能要求。据谷歌高级研究员 Jeff Dean 说，“粗略估计是你结合使用思想实验和通用性能数字来创建的估计，以良好地了解哪些设计将满足你的需求”[1]。

您需要有良好的可伸缩性基础，以有效地执行粗略估计。我们应该很好地理解以下概念：2 的次方 [2]、每个程序员都应该知道的延迟号和可用性号。

## 二的次方

尽管在处理分布式系统时，数据量可能会变得巨大，但计算归根结底是基础。为了获得正确的计算，关键是要知道使用 2 的幂的数据量单位。一个字节是一个 8 位的序列。ASCII 字符使用一个字节的内存（8 位）。下表解释了数据量单位（表 2-1）。

| 次方 | 约等于值 | 全名                 | 简写名 |
| ---- | -------- | -------------------- | ------ |
| 10   | 一千     | 1 千字节（Kilobyte） | 1 KB   |
| 20   | 一百万   | 1 兆字节（Megabyte） | 1 MB   |
| 30   | 十亿     | 1 吉字节（Gigabyte） | 1 GB   |
| 40   | 一万亿   | 1 太字节（Terabyte） | 1 TB   |
| 50   | 一千万亿 | 1 拍字节（Petabyte） | 1 PB   |

## 每个程序员都应该知道的延迟数

来自谷歌的 Dean 博士揭示了 2010 年[1]中典型计算机操作的长度。随着计算机变得更快和更强大，一些数字已经过时了。然而，这些数字仍然能够让我们了解不同计算机操作的速度和缓慢。

| 操作名                             | 时间                    |
| ---------------------------------- | ----------------------- |
| L1 缓存引用                        | 0.5 ns                  |
| 分支预测错误                       | 5 ns                    |
| L2 缓存引用                        | 7 ns                    |
| 互斥锁/解锁                        | 100 ns                  |
| 主存引用                           | 100 ns                  |
| 使用 Zippy 压缩 1K 字节            | 10,000 ns = 10 μs       |
| 通过 1 Gbps 网络发送 2K 字节       | 20,000 ns = 20 μs       |
| 从内存中连续读取 1 MB              | 250,000 ns = 250 μs     |
| 在同一数据中心内的往返             | 500,000 ns = 500 μs     |
| 磁盘寻道                           | 10,000,000 ns = 10 ms   |
| 从网络连续读取 1 MB                | 10,000,000 ns = 10 ms   |
| 从磁盘连续读取 1 MB                | 30,000,000 ns = 30 ms   |
| 发包 CA（加利福尼亚）-> 荷兰 -> CA | 150,000,000 ns = 150 ms |

一位谷歌软件工程师开发了一个工具来可视化迪恩博士的数字。该工具还考虑到了时间因素。图 2-1 显示了截至 2020 年的可视化延迟数（数据来源：参考材料[3])。

通过分析图 2-1 中的数字，我们得出以下结论：

- 内存速度快，但磁盘速度慢。
- 尽可能避免进行磁盘寻道。
- 简单的压缩算法速度很快。
- 如果可能的话，在将数据发送到互联网之前压缩数据。
- 数据中心通常位于不同的区域，在它们之间发送数据需要时间。

## 可用性数字

高可用性是指系统在所期望的长时间持续运行的能力。高可用性是以百分比来衡量的，100% 表示服务的停机时间为 0。大多数服务下降在 99% 到 100% 之间。

服务级别协议（SLA）是表示服务提供者的常用术语。这是您（服务提供商）和您的客户之间的协议，该协议正式定义了您的服务将提供的正常运行时间水平。云服务提供商 Amazon [4]、谷歌[5]和微软[6]将其 SLA 设置在 99.9% 或以上。正常运行时间传统上以 9 个为单位来衡量。9 个数字越多越好。如表 2-3 所示，9 的数量与预期的系统停机时间相关。

| 可用性 % | 平均每天停机时间 | 平均每年停机时间 |
| -------- | ---------------- | ---------------- |
| 99%      | 14.40 分钟       | 3.65 天          |
| 99.9%    | 1.44 分钟        | 8.77 小时        |
| 99.99%   | 8.64 秒          | 52.60 分钟       |
| 99.999%  | 864.00 毫秒      | 5.26 分钟        |
| 99.9999% | 86.40 毫秒       | 31.56 秒         |

## 示例：估计推特的 QPS 和存储需求

请注意，以下数字仅用于本练习，因为它们不是推特上的真实数字。

假设：

- 活跃用户为每月 3 亿。
- 50% 的用户每天都在使用推特。
- 用户平均每天发布 2 条推特。
- 10% 的推文包含多媒体。
- 数据存储时间 5 年

估计：

每秒查询次数（Query per second，QPS）估计：

- 每天活跃用户（Daily active users，DAU）= 3 亿 * 50 % = 1.5 亿
- 推特 QPS = 1.5 亿 * 2 推特 / 24 小时 / 3600 秒 = ~3500
- 查看 QPS = 2 * QPS = ~7000

这里我们将只评估多媒体存储

- 平均推特大小：
  - 推特 id 64 字节
  - 文本 140 字节
  - 多媒体 1 MB
- 多媒体存储：1.5 亿 * 2 * 10 % * 1 MB = 30 TB 每天
- 5 年多媒体存储：30 TB * 365 * 5 = ~55 PB

## 提示

粗略估计就是关于这个过程的。解决问题比取得结果更重要。面试官可能会测试你解决问题的能力。以下是一些提示：

- 取整和近似。在面试过程中，很难执行复杂的数学操作。例如，“99987/9.1”的结果是什么？没有必要花宝贵的时间来解决复杂的数学问题。精度不是预期的。最好使用整数和近似值。前面的除法问题可以简化为：“100000/10”。
- 写下你的假设。写下你的假设以供以后引用是个好主意。
- 标记你的单位。当你写下“5”时，它是指 5 KB 还是 5 MB？你可能会把自己搞混了。写下单位，因为“5MB”有助于消除歧义。
- 通常要求的粗略估计： QPS、峰值 QPS、存储、缓存、服务器数量等。你可以在准备面试时练习这些计算。熟能生巧。

祝贺你能走到这一步！现在拍拍自己的背。干得好！

# 第 3 节：系统设计面试的框架

你刚刚在你梦想中的公司得到了一个令人垂涎的现场面试。招聘协调员会给你发送当天的时间表。浏览一下列表，你会感觉很好，直到你的目光落在这个面试环节-系统设计面试。

系统设计面试通常会令人生畏。它可能就像“设计一个著名的产品X？”一样模糊。这些问题都很模棱两可，而且似乎过于宽泛。你的疲倦是可以理解的。毕竟，怎么能在一个小时内设计出一个需要数百数千名工程师制造的流行产品呢？

好消息是，没有人希望你这么做。现实世界的系统设计非常复杂的。例如，谷歌搜索看似简单；然而，支持这种简单性的技术数量确实是惊人的。如果没有人期望你在一个小时内设计出一个真实世界的系统，那么系统设计面试有什么好处呢？

系统设计访谈模拟了现实生活中的问题解决，两个同事合作解决一个模棱两可的问题，并提出一个满足他们目标的解决方案。这个问题是开放式的，而且没有一个完美的答案。与你在设计过程中投入的工作相比，最终的设计就不那么重要。这允许您展示您的设计技能，捍卫您的设计选择，并以建设性的方式回应反馈。

让我们翻翻桌子，考虑一下面试官走进会议室迎接你时脑子想的是什么。面试官的主要目标是准确地评估你的能力。她最不希望做的是给出一个不确定的评估，因为会议进展不佳，而且没有足够的信号。面试官在系统设计面试中是在寻找什么？

许多人认为，系统设计面试完全都是关于一个人的技术设计技能。这远不止于此。一个有效的系统设计面试提供了一个人的协作、在压力下工作以及建设性地解决模糊性的能力。问好问题的能力也是一项必不可少的技能，许多面试官特别寻找这种技能。

一个好的面试官也会寻找危险信号。过度工程是许多工程师的一种真正的疾病，因为他们喜欢设计的纯度，而忽略了权衡。他们往往不到过度设计系统的复合成本，许多公司为这种无知付出了高昂的代价。您当然不想在系统设计面试中展示这种趋势。其他的危险信号还包括心胸狭窄、固执等。

在本章中，我们将介绍一些有用的技巧，并介绍一个简单而有效的框架来解决系统设计面试问题。

## 有效系统设计面试的 4 步步骤

每个系统设计面试都是不同的。一个伟大的系统设计面试是开放式的，没有一刀切的解决方案。然而，在每个系统设计访谈中都有一些步骤和共同点。

# 第 6 节：设计一个键值存储

## 系统架构图

现在我们已经讨论了在设计键值存储时的不同技术考虑，我们可以将重点转移到架构图上，如图 6-17 所示。

该架构的主要特性如下：

- 客户端通过简单的 api 与键值存储进行通信：*get(key)* 和 *put(key, value)*。
- 协调器是作为客户端和键值存储之间的代理的节点。
- 节点使用一致性散列分布在一个环上。
- 该系统是完全去中心的，因此可以自动添加和移动节点。
- 数据将在多个节点上进行复制。
- 不存在单点故障，因为每个节点都有相同的责任集。

由于设计是去中心的，每个节点执行许多任务，如图 6-18 所示。

## 写路径

图 6-19 解释了将写入请求定向到特定节点后发生的情况。请注意，建议的写/读路径的设计主要是基于 Cassandra[8] 的架构。

1. 写入请求被持久地保存在提交日志文件上。
2. 数据被保存在内存缓存中。
3. 当内存缓存已满或达到预定义的阈值时，数据将被刷新到磁盘上的 SSTable [9]。注意：排序字符串表（SSTable）是<键、值>对的排序列表。如果您有兴趣了解更多关于 SStable 的读者，请参阅参考材料[9]。

## 读路径

读请求定向到特定节点后，它首先检查数据是否在内存缓存中。如果是这样，则数据将返回给客户端，如图 6-20 所示。

如果数据不在内存中，则将从磁盘中检索该数据。我们需要一种有效的方法来找出哪个 SSTable 包含该密钥。布隆（Bloom）过滤器[10]通常被用来解决这个问题。

当数据不在内存中时，读取路径如图 6-21 所示。

1. 系统首先检查内存中是否有数据。如果没有，请转到步骤2。 
2. 如果数据不在内存中，系统将检查布隆过滤器。
3. 布隆过滤器用于找出哪些 SSTables 可能包含该键。
4. SSTBables 返回数据集的结果。 
5. 该数据集的结果将返回给客户端。

## 总结

本章涵盖了许多概念和技术。要刷新内存，下表总结了用于分布式键值存储的特性和相应的技术。

| 目标/问题               | 技术                                                      |
| ----------------------- | --------------------------------------------------------- |
| 存储大数据的能力        | 使用一致性哈希来在服务器间扩展负载                        |
| 高可用性读取            | 数据复制、多数据中心配置                                  |
| 高可用性写入            | 使用向量时钟来进行版本和冲突解析                          |
| 数据集分片              | 一致性哈希                                                |
| 增加可扩展性            | 一致性哈希                                                |
| 异质性（Heterogeneity） | 一致性哈希                                                |
| 可调一致性              | 法定人数共识                                              |
| 处理临时失败            | 懒散法定人数（Sloppy quorum）和暗示交接（hinted handoff） |
| 处理永久失败            | Merkle 树                                                 |
| 处理数据中心断连        | 跨数据中心复制                                            |

# 第 7 章：在分布式系统里设计一个唯一 ID 生成器

在本章中，我们将要求您在分布式系统中设计一个唯一 ID 生成器。您的第一个想法可能是在传统数据库中使用带有 auto_increment 属性的主键。但是，auto_increment 在分布式环境中不起作用，因为单个数据库服务器不够大，并且在多个数据库中以最小的延迟跨多个数据库生成唯一的 id 具有挑战性。

以下是几个独特的 id 的例子：

## 第 1 步 - 理解问题和建立设计域

询问澄清问题是解决任何系统设计面试问题的第一步。以下是一个候选人-面试者互动的例子：

**候选人**：唯一 ID 的特点是什么？

**面试官**：ID 必须是唯一的和可排序的。

**候选人**：对于每条新记录，ID 是否增加 1？

**面试官**：ID 随时间增加，但不一定只增加 1。在晚上创建的 ID 比在当天早上创建的 ID 要大。

**候选人**：ID 只包含数值吗？

**面试官**：是的，没错。

**候选人**：ID 长度的要求是什么？

**面试官**：ID 应该适合于 64 位的位置。

**候选人**：这个系统的规模是多少？

**面试官**：该系统应该能够每秒生成 10,000 个 ID

以上是一些你可以问面试官的样本问题。理解需求和澄清歧义是很重要的。对于这个面试问题，要求如下：

- ID 必须是唯一的。
- ID 仅为数值。
- ID 适合于 64 位。
- ID 是按日期排序的。
- 每秒能够生成超过 10,000 个唯一的 ID。

## 第 2 步 - 提出高级设计并获得支持

可以使用多个选项在分布式系统中生成唯一的 ID。我们考虑的选项是：

- 多主复制
- 通用唯一标识符（UUID）
- 票证服务器
- 推特雪花方法

让我们看看每一个，它们是如何工作的，以及每个选项的优缺点。

## 多主复制

如图 7-2 所示，第一种方法是多主服务器复制。

此方法使用了数据库的自动增量特性。我们没有将下一个 ID 增加 1，而是将其增加 k，其中 k 是正在使用的数据库服务器的数量。如图 7-2 所示，要生成的下一个 ID 等于同一台服务器上的前一个 ID 加上 2。这解决了一些可伸缩性问题，因为 ID 可以随着数据库服务器的数量而扩展。然而，这种策略有一些主要的缺点：

- 很难扩展到多个数据中心
- ID 不能跨多个服务器随时间增加。
- 当添加或删除服务器时，它不能正常扩展。

## UUID

UUID 是获取唯一 ID 的另一种简单方法。UUID 是一个 128 位的数字，用于识别计算机系统中的信息。UUID 发生碰撞的可能性很低。引用维基百科的话，“在大约 100 年里每秒生成 10 亿个 UUID 后，创建一个重复的概率将达到 50%”[1]。

这里是 UUID 的一个例子： 09c93e62-50b4-468d-bf8a-c07e1040bfb2。UUID 可以独立生成，而不需要服务器之间的协调。图 7-3 显示了 UUID 的设计。

在这个设计中，每个 web 服务器都包含一个 ID 生成器，并且一个 web 服务器负责独立地生成 ID。

优点：

- 生成 UUID 很简单。服务器之间不需要进行协调，因此不会出现任何同步问题。
- 该系统很容易扩展，因为每个 web 服务器都负责生成它们所使用的 ID。ID 生成器可以很容易地扩展到 web 服务器。

缺点：

- ID 有 128 位长，但我们的要求是 64 位。
- ID 不会随时间的推移而增加。
- ID 可以是非数字的。

## 票证服务器

票证服务器（ticket servers）是生成唯一 ID 的另一种有趣的方法。Flicker 开发了票证服务器来生成分布式主密钥[2]。值得一提的是，这个系统是如何工作的。

其想法是在单个数据库服务器（票证服务器）中使用集中的自动增量功能。要了解更多相关信息，请参考 flicker 的工程博客文章[2]。

优点：

- 数字 ID。
- 它易于实现，并且适用于中小型应用程序。

缺点：

- 单点故障。单票证服务器意味着如果票证服务器宕机，所有依赖于它的系统都将面临问题。为了避免单点故障，我们可以设置多个记录单服务器。然而，这将引入新的挑战，如数据同步。

## 推特雪花算法

上面提到的方法给了我们一些关于不同的 ID 生成系统如何工作的想法。但是，它们都不满足我们的具体要求；因此，我们需要另一种方法。推特独特的 ID 生成系统“雪花”[3]非常鼓舞人心，可以满足我们的需求。

分而治之是我们的朋友。我们不是直接生成 ID，而是将 ID 划分为不同的部分。图 7-5 显示了一个 64 位 ID 的布局。

| 0     | 时间戳  | 数据中心 ID | 机器 ID | 序列号  |
| ----- | ------- | ----------- | ------- | ------- |
| 1 bit | 41 bits | 5 bits      | 5 bits  | 12 bits |

每个部分的解释如下。

- 符号位：1 位。它将始终是 0。这是留给将来使用的。它可以被用于区分有符号数字和无符号数字。
- 时间戳： 41 位。从这个时代(epoch)或自定义时代开始的毫秒。我们使用 Twitter 雪花默认时代 1288834974657，相当于 2010 年 11 月 04 日，01：42：54 UTC。
- 数据中心 ID： 5 位，这给了我们 2 ^ 5 = 32 个数据中心。
- 机器 ID： 5 位，每个数据中心有 2 ^ 5 = 32 台机器。
- 序列号： 12 位。对于在该机器/进程上生成的每个 ID，序列号将增加 1。该数字被重置为每毫秒间隔 0 次。

## 第 3 步 - 深入设计

在高级设计中，我们讨论了在分布式系统中设计一个独特的 ID 生成器的各种选项。我们选择了一种基于 Twitter 雪花 ID 生成器的方法。让我们深入研究一下这个设计吧。为了刷新我们的记忆，下面重新列出了设计图。

| 0     | 时间戳  | 数据中心 ID | 机器 ID | 序列号  |
| ----- | ------- | ----------- | ------- | ------- |
| 1 bit | 41 bits | 5 bits      | 5 bits  | 12 bits |

数据中心 ID 和机器 ID 在启动时选择，通常在系统运行后进行修复。数据中心 ID 和机器 ID 中的任何更改都需要仔细检查，因为这些值中的意外更改可能会导致 ID 冲突。时间戳和序列号是在 ID 生成器运行时生成的。

## 时间戳

最重要的 41 位构成了时间戳部分。随着时间戳随时间的增长，ID 可以按时间排序。图 7-7 显示了一个如何将二进制表示法转换为 UTC 的示例。您还可以使用类似的方法将 UTC 转换为二进制表示。

```
0-00100010101001011010011011000101101011000-01010-01100-000000000000
↓ 转为十进制
297616116568
↓ + Twitter 时代 1288834974657
1586451091225
↓ 将毫秒转为 UTC 时间
Apr 09 2020 16:51:31 UTC
```

可以用 41 位表示的最大时间戳为：2 ^ 41 - 1 = 2199023255551 毫秒（ms），这给了我们： ~ 69年= 2199023255551 ms / 1000 秒 / 365 天 / 24 小时 / 3600 秒。这意味着 ID 生成器将工作 69 年，并且有一个接近今天的日期的自定义历元时间的话，将会延迟溢出时间。69 年后，我们将需要一个新的时代时间或采用其他技术来迁移 ID。

## 序列号

序列号是 12 位，给我们 2 ^ 12 = 4096 组合。除非在同一服务器上在毫秒内生成多个 ID，否则此字段为 0。理论上，一台机器每毫秒最多可以支持 4096 个新 ID。

## 第 4 步 - 总结

在本章中，我们讨论了设计唯一 ID 生成器的不同方法：多主复制、UUID、票证服务器和类似 Twitter 雪花的唯一 ID 生成器。我们选择雪花，因为它支持我们所有的用例，并且在分布式环境中是可扩展的。

如果在面试结束时有额外的时间，这里有一些额外的谈话要点：

- 时钟同步。在我们的设计中，我们假设 ID 生成服务器具有相同的时钟。当服务器在多个核上运行时，这种假设可能不正确。同样的挑战也存在于多机器场景中。时钟同步的解决方案超出了这本书的范围；然而，理解这个问题的存在是很重要的。网络时间协议是解决这个问题的最流行的解决方案。对于感兴趣的读者，请参考参考资料[4]。
- 部分长度调整。例如，更少的序列号和更多的时间戳位对于低并发性和长期应用程序是有效的。
- 高可用性。由于 ID 生成器是一个关键任务系统，因此它必须具有高度的可用性。

祝贺你能走到这一步！现在拍拍自己的背。干得好

# 第 8 章：设计一个 URL 缩短器

在本章中，我们将讨论一个有趣而又经典的系统设计面试问题：设计一个像 tinyurl 这样的 URL 缩短服务。

## 第 1 步 - 了解问题，确定设计范围

系统设计的面试问题是故意保持开放式的。要设计一个精心设计的系统，提出澄清问题是至关重要的。

**候选人**：你能举一个URL缩短器如何工作的例子吗？

**面试官**：假设 URL https://www.systeminterview.com/q=chatsystem&c=loggedin&v=v3&l=long 是原始的 URL。您的服务将创建一个长度较短的别名： https://tinyurl.com/y7keocwj。如果单击别名，它将将您重定向到原始 URL。

**候选人**：访问流量是多少？

**面试官**：每天生成 1 亿个 URL。

**候选人**：缩短的 URL 是多长？

**面试官**：尽可能的简短。

**候选人**：在缩短的 URL 中允许使用哪些字符？

**面试官**：缩短的 URL 可以是数字（0-9）和字符（a-z、A-Z）的组合。

**候选人**：缩短的 URL 可以被删除或更新吗？

**面试官**：为了简单起见，让我们假设缩短的 URL 不能被删除或更新。

下面是最基本的用例：

1. URL 缩短：给定一个较长的 URL，=> 返回一个更短的 URL
2. URL 重定向：给定一个较短的 URL => 重定向到原始的 URL
3. 具有高可用性、可伸缩性和容错性的考虑

## 粗略估计

- 写操作：每天生成 1 亿个 URL。
- 写操作每秒：1 亿 / 24 / 3600 = 1160
- 读操作：假设读操作写操作是 10：1，读操作每秒：1160 * 10=11600
- 假设 URL 缩短服务将运行 10 年，这意味着我们必须支持 1 亿 * 365 * 10= 3650 亿记录。
- 假设平均 URL 长度为 100。
- 超过 10 年的存储需求：3650 亿 * 100 字节 * 10 年 = 365 TB

对你来说，和面试官一起进行假设和计算是很重要的，这样你们俩都意见一致。

## 第 2 步 - 提出高级设计并获得支持

在本节中，我们将讨论 API 端点、URL 重定向和 URL 缩短流。

## API 端点

API 端点促进了客户机和服务器之间的通信。我们将 API 设计为 REST 风格。如果您不熟悉 restful API，您可以查阅外部材料，如参考材料[1]中的材料。URL 缩短器主节点需要两个 API 端点。 

1. URL 的缩短。要创建一个新的短 URL，客户端将发送一个 POST 请求，其中包含一个参数：原始的长 URL。API 看起来如下：

   POST api/v1/data/shorten

   - 请求参数：{longUrl: longURLString}
   - 返回短 URL

2. URL 重定向。要将一个短 URL 重定向到相应的长 URL，客户端将发送一个 GET 请求。API 看起来是这样的：

   GET api/v1/shortUrl

   - 返回长 URL 到 HTTP 重定向

## URL 重定向

图 8-1 显示了当您在浏览器上输入 tinyurl 时发生的情况。一旦服务器收到一个 tinyurl 请求，它将将短 URL 更改为具有 301 重定向的长 URL。

客户机和服务器之间的详细通信如图 8-2 所示。

这里值得讨论的一件事是 301 重定向 vs 302 重定向。

**301 重定向**。301 重定向显示所请求的 URL 被“永久”移动到长 URL。由于它是永久重定向的，因此浏览器会缓存响应，并且对相同 URL 的后续请求将不会被发送到 URL 缩短服务。相反，请求被直接重定向到长 URL 服务器。

**302 重定向**。302 重定向意味着 URL 被“暂时”移动到长 URL，这意味着对相同 URL 的后续请求将首先被发送到 URL 缩短服务。然后，它们被重定向到长 URL 服务器。

每种重定向方法都有其优缺点。如果优先级是减少服务器负载，使用 301 重定向是有意义的，因为只有相同 URL 的第一个请求被发送到 URL 缩短服务器。然而，如果分析是重要的，302 重定向是一个更好的选择，因为它可以更容易地跟踪点击率和点击的来源。

实现 URL 重定向的最直观的方法是使用哈希表。假设散列表存储 `<短 URL，长 URL>` 对，URL 重定向可以通过以下方式实现：

- 获取长 URL：longURL = hashTable.get(shortURL)
- 一旦获得 longURL 后，执行 URL 重定向。

## 缩短 URL

让我们假设短 URL 的外观如下： www.tinyurl.com/{hashValue}。为了支持 URL 缩短用例，我们必须找到一个哈希函数 fx，它映射一个长 URL 到 hashValue，如图 8-3 所示。

散列函数必须满足以下要求：

- 每个长 URL 必须散列到一个哈希值。
- 每个哈希值都可以映射回长 URL。

在深度研究中讨论了哈希函数的详细设计。

## 第 3 步 - 深入设计

到目前为止，我们已经讨论了 URL 缩短和 URL 重定向的高级设计。在本节中，我们将深入研究以下内容：数据模型、哈希函数、URL 缩短和 URL 重定向。

## 数据模型

在高级设计中，所有内容都存储在一个哈希表中。这是一个很好的起点；然而，由于内存资源有限且昂贵，这种方法对于现实系统是不可行的。一个更好的选择是在关系数据库中存储 <shourtURL、longURL> 映射。图 8-4 显示了一个简单的数据库表设计。该表的简化版本包含 3 列： id、shortURL、longURL。

## 哈希函数

散列函数用于将一个长 URL 散列到一个短 URL，也称为散列值（hashValue）。

## 哈希值长度

哈希值由来自 [0-9、a-z、A-Z] 的字符组成，其中包含 10 + 26 + 26 = 62 个可能的字符。要计算出哈希值的长度，找到最小的 n，即 62^n ≥ 3650 亿。基于粗略估计，该系统必须支持多达 3650 亿个 URL。表 8-1 显示了散列值的长度及其所能支持的最大 URL 数。

| N    | URL 数量最大值                       |
| ---- | ------------------------------------ |
| 1    | 62^1 = 62                            |
| 2    | 62^2 = 3,844                         |
| 3    | 62^3 = 238,328                       |
| 4    | 62^4 = 14,776,336                    |
| 5    | 62^5 = 916,132,832                   |
| 6    | 62^6 = 56,800,235,584                |
| 7    | 62^7 = 3,521,614,606,208 = ~3.5 万亿 |

当 n = 7, 62 ^ n = ~3.5 万亿，3.5 万亿足以超过 3650 亿个 URL，所以哈希值的长度是 7。

我们将探索一个 URL 缩短器的两种类型的哈希函数。第一个是“哈希 + 碰撞解析”，第二个是“基 62 转换”。让我们一个接一个地看它们。

## 哈希 + 碰撞解析

为了缩短一个长的 URL，我们应该实现一个哈希函数，它将一个长的 URL 散列到一个包含 7 个字符的字符串中。一个简单的解决方案是使用著名的哈希函数，如CRC32、MD5 或 SHA-1。下表比较了在此 URL 上应用不同的哈希函数后的哈希结果： https://en.wikipedia.org/wiki/Systems_design。

| 哈希函数 | 哈希值（十六进制）                       |
| -------- | ---------------------------------------- |
| CRC32    | 5cb54054                                 |
| MD5      | 5a62509a84df9ee03fe1230b9df8b84e         |
| SHA-1    | 0eeae7916c06853901d9ccbefbfcaf4de57ed85b |

如表 8-2 所示，即使是最短的哈希值（来自 CRC32）也太长（超过 7 个字符）。我们怎样才能让它更短呢？

第一种方法是收集哈希值的前 7 个字符；但是，这种方法可能会导致哈希冲突。为了解决哈希冲突，我们可以递归地附加一个新的预定义字符串，直到没有发现更多的冲突为止。图 8-5 解释了这个过程。

该方法可以消除冲突；但是，查询数据库以检查每个请求是否存在 shortURL 是代价高昂的。一种叫做布隆过滤器[2]的技术可以提高性能。布隆过滤器是一种空间有效的概率技术，用于测试一个元素是否是一个集合的成员。详情请参考参考资料[2]。

## 基 62 转换

基转换是 URL 缩短器常用的另一种方法。基转换有助于在其不同的数字表示系统之间转换相同的数字。使用基 62 转换，因为散列值有 62 个字符。让我们用一个例子来解释转换是如何工作的：将 $11157_{10}$ 转换为基 62 表示。

（$11157_{10}$ 表示基底 10 系统中的 11157）。

- 从它的名字来看，基 62 是一种使用 62 个字符进行编码的方式。映射分别是： 0-0、...，9-9、10-a、11-b、...，35-z、36-A、...，61-Z，其中“a”代表10，“Z”代表61，等等。
- $11157_{10} = 2 \times 62^2 + 55 \times 62^1 + 59 \times 62^0$ = [2, 55, 59] -> 在基 62 中表达为 [2, T, X]。图 8-6 显示了会话过程。
- 因此，较短的 URL 是 https://tinyurl.com/2TX

## 这两种方法的比较

表 8-3 显示了两种方法的差异

| 哈希 + 碰撞解析                                 | 基 62 转换                                                   |
| ----------------------------------------------- | ------------------------------------------------------------ |
| 固定的短 URL 长度                               | 短 URL 的长度是不确定的。它随 ID 增长                        |
| 它不需要一个唯一 ID 生成器                      | 这个选择依赖于一个唯一 ID 生成器                             |
| 可能碰撞且必须被处理                            | 不可能碰撞因为 ID 是唯一的                                   |
| 不可能判断出下一个可用短 URL，因为它不取决于 ID | 如果 ID 按 1 递增则很容易判断下一个可用短 URL。这可能是一个安全问题。 |

## 深入研究 URL 缩短

作为系统的核心部分之一，我们希望 URL 缩短流在逻辑上具有简单性和功能性。我们的设计中使用了基 62 转换。我们构建了下面的图表（图 8-7）来演示这个流程。

1. longURL 是输入。
2. 系统会检查该 longURL 是否在数据库中。
3. 如果是，则意味着 longURL 之前已被转换为 shortURL。在这种情况下，从数据库中获取 shortURL 并将其返回给客户端。
4. 如果不是，则该 longURL 是新的。一个新的唯一 ID（主键）由唯一 ID 生成器生成。
5. 将 ID 转换为 shortURL。
6. 创建一个具有 ID、shortURL 和 longURL 的新数据库行。

为了使流程更容易理解，让我们来看看一个具体的例子。

- 假设输入的长 URL 为： https://en.wikipedia.org/wiki/Systems_design
- 唯一 ID 生成器返回 ID：2009215674938。
- 使用基 62 转换将 ID 转换为 shortURL。ID（2009215674938）被转换为“zn9edcu”。
- 将 ID、shortURL 和 longURL 保存到数据库中，如表 8-4 所示。

分布式唯一 ID 生成器值得一提。它的主要功能是生成全局唯一的 id，用于创建 shortURL。在高度分布式的环境中，实现唯一的 ID 生成器是一项挑战。幸运的是，我们已经在“第 7 章：在分布式系统中设计一个唯一 ID 生成器”中讨论了一些解决方案。你可以参考它来刷新你的记忆。

## 深入研究 URL 重定向

图 8-8 显示了 URL 重定向的详细设计。由于读多于写，<短 URL，长 URL>映射存储在缓存中以提高性能。

URL 重定向的流程总结如下：

1. 用户单击一个简短的 URL 链接： https://tinyurl.com/zn9edcu
2. 负载均衡器将请求转发到 web 服务器。
3. 如果缓存中已经在 shortURL 中，请直接返回 longURL。
4. 如果缓存中不存在 shortURL，请从数据库中获取 longURL。如果它不在数据库中，则很可能是一个用户输入了一个无效的 shortURL。
5. 该 longURL 将返回给该用户。

## 第 4 步 - 总结

在本章中，我们将谈到 API 的设计、数据模型、哈希函数、URL 缩短和 URL 重定向。

如果在面试结束时有额外的时间，这里有一些额外的谈话要点。

- 速率限制器：我们可能面临的一个潜在的安全问题是，恶意用户发送了压倒性的大量 URL 缩短请求。速率限制器有助于基于 IP 地址或其他过滤规则过滤出请求。如果你想刷新你的关于速率限制的记忆，请参考“第 4 章：设计一个速率限制器”。
- Web 服务器缩放：由于 Web 层是无状态的，因此通过添加或删除 Web 服务器很容易扩展 Web 层。
- 数据库缩放：数据库复制和分片化是常见的技术。
- 分片：数据对业务的成功越来越重要。将一个分片解决方案集成到 URL 缩短器中可以帮助回答一些重要的问题，比如有多少人点击了一个链接？他们什么时候点击链接？等
- 可用性、一致性和可靠性。这些概念是任何大型系统成功的核心。我们在第一章中详细讨论了它们，请刷新您对这些主题的记忆。

祝贺你能走到这一步！现在拍拍自己的背。干得好！

# 第 9 章：设计一个网络爬虫

在本章中，我们将重点关注网页爬虫设计：一个有趣而经典的系统设计面试问题。

网络爬虫被称为机器人或蜘蛛。它被搜索引擎广泛用于发现网络上新的或更新的内容。内容可以是网页、图像、视频、PDF 文件等。一个网络爬虫者首先收集一些网页，然后跟踪这些页面上的链接来收集新的内容。图 9-1 显示了这个爬行过程的一个可视化示例。

爬虫可用于许多用途：

- 搜索引擎索引：这是最常见的用例。一个爬虫会收集网页，为搜索引擎创建一个本地索引。例如，谷歌机器人是谷歌搜索引擎背后的网络爬虫。
- Web 存档：这是一个从网络中收集信息以保存数据以供将来使用的过程。例如，许多国家图书馆运行爬虫来存档网站。值得注意的例子是美国国会图书馆的[1]和欧盟的网络档案[2]。
- 网络挖掘：网络的爆炸性增长为数据挖掘提供了前所未有的机会。网络挖掘有助于从互联网上发现有用的知识。例如，顶级金融公司使用爬虫程序下载股东大会和年度报告，以了解公司的关键举措。
- 网络监控。这些爬虫程序帮助监控互联网上的版权和商标侵权行为。例如，数字弧[3]利用爬虫来发现盗版作品和报告。

开发一个网络爬虫的复杂性取决于我们打算支持的规模。它可以是一个只需要几个小时就能完成的小型学校项目，也可以是一个需要由专门的工程团队持续改进的大型项目。因此，我们将在下面探讨所支持的规模和特性。

## 第 1 步 - 了解问题，确定设计范围

网络爬虫的基本算法很简单：

1. 给定一组 URL，请下载该 URL 地址所在的所有网页。 
2. 从这些网页中提取 URL
3. 向要下载的 URL 列表中添加新的 URL。重复这 3 个步骤。

一个网络爬虫的工作原理真的像这个基本的算法一样简单吗？不完全是。设计一个非常可伸缩的网络爬虫是一项极其复杂的任务。任何人都不太可能在面试期间设计出一个巨大的网络爬虫。在进入设计之前，我们必须提出问题，以理解要求并确定设计范围：

**候选人**：爬虫器的主要目的是什么？它是用于搜索引擎索引、数据挖掘还是其他东西？

**面试官**：搜索引擎索引。

**候选人**：网络爬虫每月收集多少个网页？

**面试官**：10 亿页。

**候选人**：包括哪些内容类型？仅限 HTML 或其他内容类型，如 PDF 和图像，以及？

**面试官**：仅 HTML。

**候选人**：我们是否应该考虑新添加或编辑的网页？

**面试官**：是的，我们应该考虑新添加或编辑的网页。

**候选人**：我们需要存储从网络爬取的 HTML 页面吗？

**面试官**：是的，长达 5 年

**候选人**：我们如何处理带有重复内容的网页？

**面试官**：应该忽略内容重复的页面。

以上是一些你可以问面试官的样本问题。理解需求和澄清歧义是很重要的。即使你被要求设计一个像网络爬虫一样简单的产品，你和你的面试官也可能没有相同的假设。

除了与面试官澄清的功能外，注意一个好的网络爬虫的以下特征也很重要：

- 可伸缩性：网络非常大。那里有数十亿个网页。使用并行化，Web 爬行应该非常高效。
- 健壮性：网络上充满了陷阱。错误的 HTML，无响应的服务器，崩溃，恶意链接等。都是很常见的。爬虫必须处理所有这些边缘的情况。
- 礼貌：爬虫不应该在很短的时间间隔内对一个网站发出太多的请求。
- 可扩展性：该系统非常灵活，因此需要进行最小限度的更改来支持新的内容类型。例如，如果我们想在将来抓取图像文件，我们不需要重新设计整个系统。

## 粗略估计

下面的估计是基于许多假设的，与面试官的沟通是很重要的。

- 假设每月下载 10 亿个网页。
- QPS：10000000000 / 30 天 / 24 小时 / 3600 秒= ~400 页每秒。
- 峰值 QPS = 2 * QPS = 800
- 假设平均网页大小为 500k。
- 10 亿页 x 500k = 500 TB存储。如果您不清楚数字存储单元，请再次阅读第二章中的“二的次方”部分。
- 假设数据存储 5 年，500 TB * 12 个月 * 5 年 = 30 PB。需要一个 30 PB 的存储空间来存储五年期的内容。

## 第 2 步 - 提出高级设计，并获得支持

一旦需求明确了，我们就会转向高级设计。受之前关于网络爬行[4] [5]的研究的启发，我们提出了一个如图 9-2 所示的高级设计。

首先，我们将探索每个设计组件，以理解它们的功能。然后，我们一步一步地检查爬虫工作流。

## 种子 URL

web 爬虫程序使用种子 URL 作为爬虫过程的起点。例如，要从一个大学的网站上抓取所有的网页，选择种子 URL 的一个直观的方法是使用该大学的域名。

为了爬行整个网络，我们需要在创造性地选择种子 URL。一个好的种子 URL 可以作为一个很好的起点，爬虫可以利用它来遍历尽可能多的链接。一般的策略是将整个 URL 空间分成更小的空间。第一种方法是基于地点，因为不同的国家可能有不同的流行网站。另一种方法是根据主题选择种子 URL；例如，我们可以将 URL 空间划分为购物、体育、医疗保健等。种子 URL 的选择是一个开放式的问题。你不被期望给出完美的答案。只需要大声把想法说出来。

## URL 边界

大多数现代的网络爬虫程序将爬网状态分为两部分：要下载和已经下载。存储要下载的 URL 的组件称为 URL 边界（Frontier）。您可以将其称为先入先出（FIFO）队列。有关 URL 边界的详细信息，请参考深入研究。

## HTML 下载器

HTML 下载器从互联网上下载网页。这些 URL 是由 URL 边界提供的。

## DNS 解析器

要下载网页，必须将 URL 转换为 IP 地址。HTML 下载器调用 DNS 解析器以获取 URL 的相应 IP 地址。例如，URL www.wikipedia.org 在 2019 年 3 月 5 日被转换为 IP 地址 198.35.26.96。

## 内容解析器

下载网页后，必须对其进行解析和验证，因为格式错误的网页可能会引发问题并浪费存储空间。在爬网服务器中实现内容解析器将减缓爬行进程。因此，内容解析器是一个单独的组件。

## 是否看过内容？

在线研究[6]显示，29% 的网页是重复的内容，这可能会导致相同的内容被多次存储。我们介绍了“内容看过了吗？”采用数据结构，消除数据冗余，缩短处理时间。它可以帮助检测以前存储在系统中的新内容。为了比较两个 HTML 文档，我们可以逐字符比较它们。然而，这种方法是缓慢和耗时的，特别是当涉及到数十亿个的网页时。完成这项任务的一个有效方法是比较两个网页[7]的哈希值。

## 内容存储

它是一个用于存储 HTML 内容的存储系统。存储系统的选择取决于数据类型、数据大小、访问频率、使用寿命等因素。同时使用了磁盘和内存。

- 大部分内容都存储在磁盘上，因为数据集太大，无法存储在内存中。
- 流行的内容被保存在内存中，以减少延迟。

## URL 提取器

URL 提取器从 HTML 页面中解析和提取链接。图 9-3 显示了一个链接提取过程的示例。通过添加“https://en.wikipedia.org”前缀，相对路径被转换为绝对 URL。

## URL 过滤器

URL 过滤器排除了某些“黑名单”站点中的内容类型、文件扩展名、错误链接和 URL。

## 网址看过了吗？

“网址看过了吗？”是一种数据结构，它跟踪在边界之前或已经访问过的 URL。“网址被看过了吗？”有助于避免多次添加相同的 URL，因为这可能会增加服务器负载，并导致潜在的无限循环。

Bloom 过滤器和哈希表是实现“已看过的 URL？”组成部分。我们将不介绍 bloom 过滤器和哈希表的详细实现。有关更多信息，请参考参考资料[4] [8]。

## URL 存储

URL 存储存储已经访问了的 URL。

到目前为止，我们已经讨论了每一个系统组件。接下来，我们将它们放在一起来解释工作流程。

## Web 爬虫工作流

为了更好地逐步解释工作流程，在设计图中添加了序列号，如图 9-4 所示。

步骤 2： HTML 下载器从 URL 边界获取一个 URL 列表。

步骤 3： HTML 下载器从 DNS 解析器获得 URL 的 IP 地址并开始下载。

步骤 4：内容解析器解析 HTML 页面，并检查页面是否格式错误。

步骤 5：解析和验证内容后，将其传递到“看过的内容？”组成部分

步骤 6：“已看过内容”组件检查 HTML 页面是否已经在存储中。

- 如果它在存储中，这意味着已经处理了不同 URL 中的相同内容。在这种情况下，HTML 页面将被丢弃。
- 如果它不在存储器中，则系统以前没有处理过相同的内容。该内容将被传递给链接提取器。

步骤 7：链接提取器从 HTML 页面中提取链接。

步骤 8：已提取的链接被传递到 URL 过滤器。

步骤 9：过滤链接后，它们被传递到“看过的 URL？”组成部分

步骤 10：“看过的 URL”组件检查 URL 是否已经在存储中，如果是，则之前进行处理，不需要做任何操作。

步骤 11：如果以前没有处理过 URL，则将其添加到 URL 边界中。

## 第 3 步 - 深入设计

到目前为止，我们已经讨论了高级设计。接下来，我们将深入讨论最重要的构建组件和技术：

- 深度优先搜索（DFS）和广度优先搜索（BFS）
- URL 边界
- HTML 下载器
- 健壮性
- 可扩展性
- 检测和避免有问题的内容

## DFS vs BFS

您可以将 web 看作是一个有向图，其中 web 页面作为节点，而超链接（URL）作为边。爬网过程可以看作是将一个有向图从一个网页到其他网页。两种常见的图遍历算法分别是 DFS 和 BFS。然而，DFS 通常不是一个很好的选择，因为 DFS 的深度可能很深。

BFS 通常被 web 爬虫使用，并由先入先出（FIFO）队列实现。在 FIFO 队列中，URL 按其排队的顺序退出队列。但是，这个实现有两个问题：

- 来自同一网页的大多数链接都被链接回同一个主机。在图 9-5 中，wikipedia.com 中的所有链接都是内部链接，这使得爬虫程序忙于处理来自同一主机（wikipedia.com）的 URL。当爬虫者试图并行下载网页时，维基百科的服务器将会收到大量的请求。这被认为是“不礼貌的”。
- 标准 BFS 没有考虑到 URL 的优先级。网络很大，并不是每个页面都有相同的质量和重要性水平。因此，我们可能希望根据 URL 的页面排名、网络流量、更新频率等，对其进行优先排序。

## URL 边界

URL 边界技术有助于解决这些问题。URL 边界是存储要下载的 URL 的数据结构。URL 边界是确保礼貌、URL 优先级和新鲜度的重要组成部分。在参考文献[5] [9]中提到了一些关于 URL 边界的值得注意的论文。这些论文的研究结果如下：

## 礼貌性

一般来说，web 爬虫应该避免在短时间内向同一主机服务器发送太多的请求。发送过多的请求被认为是“不礼貌的”，甚至被视为拒绝服务（DOS）攻击。例如，在没有任何约束的情况下，爬虫程序可以每秒钟向同一个网站发送数千个请求。这可能会淹没 web 服务器。

加强礼貌的一般想法是一次从同一台主机上下载一个页面。可以在两个下载任务之间添加一个延迟。礼貌约束是通过维护一个从网站主机名到下载（工作人员）线程的映射来实现的。每个下载器线程都有一个单独的 FIFO 队列，并且只下载从该队列获得的 URL。图 9-6 显示了管理礼貌的设计。

- 队列路由器：它确保每个队列（b1、b2、... bn）只包含来自同一主机的 URL。
- 映射表：它将每个主机映射到一个队列。
- FIFO 队列 b1、b2 到 bn：每个队列包含来自同一主机的 URL。
- 队列选择器：每个工作线程都被映射到一个 FIFO 队列，并且它只从该队列中下载 URL。队列选择逻辑将由队列选择器来完成。
- 工作线程 1 到 N。一个工作线程从同一主机逐个下载网页。可以在两个下载任务之间添加一个延迟。

## 优先级

一个论坛上随机发布的关于苹果产品的帖子与苹果主页上的帖子非常不同。尽管他们都有“苹果”的关键字，但爬虫先爬取苹果主页是明智的。

我们根据有用性对 URL 进行优先排序，这可以通过页面排名[10]、网站流量、更新频率等来衡量。“优先级器”是处理 URL 优先级化的组件。有关此概念的深入信息，请参阅参考材料[5] [10]。

图 9-7 显示了管理 URL 优先级的设计。

- 优先级器：它以 URL 作为输入并计算优先级。
- 队列 f1 到 fn：每个队列都有一个指定的优先级。选择优先级高的队列。
- 队列选择器：随机选择一个偏向于具有更高优先级的队列的队列。

图 9-8 展示了 URL 边界设计，它包含两个模块：

- 前端队列：管理优先级
- 后退队列：管理礼貌

## 新鲜度

网页不断地被添加、删除和编辑。一个网络爬虫必须定期重新计算下载的页面，以保持我们的数据集的新鲜感。重新爬取所有的 URL 是耗时和资源密集型的。优化新鲜度的策略如下：

- 根据网页的更新历史重新创建。
- 优先考虑 URL，并更频繁地重新绘制重要页面。

## URL 边界的存储

在搜索引擎的现实爬行中，前沿的 URL 数量可能是数亿[4]。把所有东西放在内存中既不持久也不能可扩展。保持在磁盘中的所有东西是不可取的，因为磁盘很慢；而且它很容易成为爬网的瓶颈。

我们采用了一种混合的方法。大多数 URL 都存储在磁盘上，因此存储空间不是问题。为了减少从磁盘读取和写入磁盘的成本，我们在内存中维护缓冲区以用于排队/脱队列操作。缓冲区中的数据会定期被写入磁盘。

## HTML 下载器

HTML 下载器使用 HTTP 协议从互联网上下载网页。在讨论 HTML 下载器之前，我们要先看看机器人排除协议。

## Robots.txt

Robots.txt，被称为机器人排除协议，是网站用于与爬虫通信的标准。它指定了允许下载哪些页面爬虫程序。在尝试抓取一个网站之前，爬虫应该首先检查它相应的 robots.txt 并遵循它的规则。

为了避免重复下载 robots.txt 文件，我们缓存了该文件的结果。文件定期下载并保存到缓存。这是一个来自 https://www.amazon.com/robots.txt 的 robots.txt 文件。部分文件夹，例如 createrhub，对于谷歌机器人来说是不允许的。

```
User-agent: Googlebot
Disallow: /creatorhub/*
Disallow: /rss/people/*/reviews
Disallow: /gp/pdp/rss/*/reviews
Disallow: /gp/cdp/member-reviews/
Disallow: /gp/aw/cr/
```

除了 robots.txt 之外，性能优化也是我们将介绍的 HTML 下载器的另一个重要概念。

## 性能优化

下面是针对 HTML 下载器的性能优化列表。

## 1. 分布式爬网

为了实现高性能，爬网作业被分配到多个服务器中，每个服务器运行多个线程。URL 空间被划分成更小的部分；因此，每个下载器都负责 URL 的一个子集。图 9-9 显示了一个分布式爬网的示例。

## 2. 缓存DNS解析器

DNS 解析器是爬虫程序的一个瓶颈，因为由于许多 DNS 接口的同步特性，DNS 请求可能需要时间。DNS 响应时间范围为 10 ms到 200 ms。一旦一个爬虫线程执行了对 DNS 的请求，其他线程就会被阻塞，直到第一个请求完成。维护我们的 DNS 缓存以避免频繁调用 DNS 是一种有效的速度优化技术。我们的 DNS 缓存保持域名到 IP 地址映射，并通过 cron 作业定期更新。

## 3. 局部性

在地理位置上分发爬网服务器。当爬网服务器更接近网站主机时，爬虫会体验到更快的下载时间。设计局部性适用于大多数系统组件：爬网服务器、缓存、队列、存储等。

## 4. 超时时间短

一些 web 服务器响应缓慢或可能根本不响应。为了避免长时间等待，指定了最大等待时间。如果主机在预定义的时间内没有响应，爬虫将停止作业并抓取其他页面。

## 健壮性

除了性能优化外，鲁棒性也是一个重要的考虑因素。我们提出了几种方法来提高系统的鲁棒性：

- 一致性哈希：这有助于在下载者之间分配负载。可以使用一致性哈希方式来添加或删除新的下载器服务器。更多细节请参考第 5 章：设计一致性哈希。
- 保存爬网状态和数据：为了防止故障，系统会将爬网状态和数据写入存储系统。通过加载已保存的状态和数据，可以轻松地重新启动中断的爬网。
- 异常处理：错误在大规模系统中是不可避免的和常见的。爬虫程序必须优雅地处理异常，而不会使系统崩溃。
- 数据验证：这是防止系统错误的一个重要措施。

## 扩展性

随着几乎每个系统的发展，设计目标之一是使系统足够灵活，以支持新的内容类型。该爬虫器可以通过插入新的模块来进行扩展。图 9-10 显示了如何添加新的模块。

- PNG 下载器模块已插入以下载 PNG 文件。
- Web 监控模块，以监控网络，防止版权和商标侵权。

## 检测并避免有问题的内容

本节讨论对冗余、无意义或有害内容的检测和预防。

## 1. 冗余内容

如前所述，近 30% 的网页是重复的。哈希值或校验和值有助于检测重复的[11]。

## 2. 蜘蛛陷阱

蜘蛛陷阱是一个网页，它会导致一个无限循环中的爬虫。例如，一个无限深度的目录结构如下： www.spidertrapexample.com/foo/bar/foo/bar/foo/bar/...

这种蜘蛛陷阱可以通过设置 URL 的最大长度来避免。然而，没有一个适合全部场景的大小的解决方案来检测蜘蛛陷阱。包含蜘蛛陷阱的网站很容易被识别，因为在这些网站上发现了异常大量的网页。很难开发出自动算法来避免蜘蛛陷阱；然而，用户可以手动验证和识别蜘蛛陷阱，并将这些网站从爬虫中排除出来，或者应用一些定制的 URL 过滤器。

## 3. 数据噪音

有些内容只有很少或根本没有价值，比如广告、代码片段、垃圾邮件 URL 等。这些内容对爬虫没有用处，如果可能，应该排除在外。

## 第 4 步 - 总结

在本章中，我们首先讨论了一个良好的爬虫器的特征：可伸缩性、礼貌性、可扩展性和鲁棒性。然后，我们提出了一个设计方案，并讨论了关键组件。构建一个可伸缩的 web 爬虫并不是一个简单的任务，因为 web 非常大，而且充满了陷阱。虽然我们已经涵盖了许多主题，但我们仍然错过了许多相关的谈话要点：

- 服务器端渲染：许多网站使用像 JavaScript、AJAX 等这样的脚本来动态地生成链接。如果我们直接下载和解析网页，我们将无法检索动态生成的链接。为了解决这个问题，我们在解析页面[12]之前也先执行服务器端渲染（也称为动态渲染）。
- 过滤掉不需要的页面：由于有限的存储容量和爬行资源，反垃圾邮件组件有利于过滤掉低质量和垃圾邮件页面[13] [14]。
- 数据库复制和分片：诸如复制和分片等技术被用于提高数据层的可用性、可伸缩性和可靠性。
- 水平缩放：对于大规模抓取，需要数百甚至数千台服务器来执行下载任务。关键是要保持服务器的无状态状态。
- 可用性、一致性和可靠性：这些概念是任何大型系统成功的核心。我们在第一章中详细地讨论了这些概念。刷新你对这些主题的记忆。
- 分析：收集和分析数据是任何系统的重要组成部分，因为数据是微调的关键成分。

祝贺你能走到这一步！现在拍拍自己的背。干得好！

# 第 10 章：设计一个通知系统